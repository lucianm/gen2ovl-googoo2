diff --git a/display.c b/display.c
index a3b3a58..4b6fdfa 100644
--- a/display.c
+++ b/display.c
@@ -18,7 +18,7 @@
 #include "setup.h"
 #include "display.h"
 #include "txtfont.h"
-    
+
 // Static variables of Display:: namespace
 Display::Mode Display::mode=Display::Full;
 cDisplay *Display::display=NULL;
@@ -26,55 +26,49 @@ cDisplay *Display::display=NULL;
 
 void Display::SetMode(Display::Mode NewMode) {
     // (re-)set display mode.
-    
+
     if (display!=NULL && NewMode==mode) return;
     // No change, nothing to do
 
     // OSD origin, centered on VDR OSD
     int x0=Setup.OSDLeft+(Setup.OSDWidth-ttSetup.OSDwidth)*ttSetup.OSDHAlign/100;
     int y0=Setup.OSDTop +(Setup.OSDHeight-ttSetup.OSDheight)*ttSetup.OSDVAlign/100;
-    
+
     switch (NewMode) {
     case Display::Full:
         // Need to re-initialize *display:
         Delete();
-        // Try 4BPP display first:
-        display=new cDisplay4BPP(x0,y0,ttSetup.OSDwidth,ttSetup.OSDheight);
-        if (!display->Valid()) {
-            // Failed, possibly out of memory 
-            delete display;
-            // Try 2BPP display
-            display=new cDisplay2BPP(x0,y0,ttSetup.OSDwidth,ttSetup.OSDheight);
-        }
+        // Try 32BPP display first:
+        display=new cDisplay32BPP(x0,y0,ttSetup.OSDwidth,ttSetup.OSDheight);
         break;
     case Display::HalfUpper:
         // Shortcut to switch from HalfUpper to HalfLower:
         if (mode==Display::HalfLower) {
             // keep instance.
-            ((cDisplay4BPPHalf*)display)->SetUpper(true);
+            ((cDisplay32BPPHalf*)display)->SetUpper(true);
             break;
         }
         // Need to re-initialize *display:
         Delete();
-        display=new cDisplay4BPPHalf(x0,y0,ttSetup.OSDwidth,ttSetup.OSDheight,true);
+        display=new cDisplay32BPPHalf(x0,y0,ttSetup.OSDwidth,ttSetup.OSDheight,true);
         break;
     case Display::HalfLower:
         // Shortcut to switch from HalfUpper to HalfLower:
         if (mode==Display::HalfUpper) {
             // keep instance.
-            ((cDisplay4BPPHalf*)display)->SetUpper(false);
+            ((cDisplay32BPPHalf*)display)->SetUpper(false);
             break;
         }
         // Need to re-initialize *display:
         Delete();
-        display=new cDisplay4BPPHalf(x0,y0,ttSetup.OSDwidth,ttSetup.OSDheight,false);
+        display=new cDisplay32BPPHalf(x0,y0,ttSetup.OSDwidth,ttSetup.OSDheight,false);
         break;
-    }           
+    }
     mode=NewMode;
     // If display is invalid, clean up immediately:
     if (!display->Valid()) Delete();
     // Pass through OSD black transparency
-    SetBackgroundColor((tColor)ttSetup.configuredClrBackground);    
+    SetBackgroundColor((tColor)ttSetup.configuredClrBackground);
 }
 
 void Display::ShowUpperHalf() {
@@ -86,113 +80,59 @@ void Display::ShowUpperHalf() {
 }
 
 
-
-
-
-
-cDisplay2BPP::cDisplay2BPP(int x0, int y0, int width, int height) 
+cDisplay32BPP::cDisplay32BPP(int x0, int y0, int width, int height)
     : cDisplay(width,height) {
-    // 2BPP display with color mapping
+    // 32BPP display for True Color OSD providers
 
     osd = cOsdProvider::NewOsd(x0, y0);
     if (!osd) return;
-   
-    width=(width+3)&~3;
-    // Width has to end on byte boundary, so round up
-    
-    tArea Areas[] = { { 0, 0, width - 1, height - 1, 2 } };
-    if (osd->CanHandleAreas(Areas, sizeof(Areas) / sizeof(tArea)) != oeOk) {
-        DELETENULL(osd);
-        return;
-    }   
-    osd->SetAreas(Areas, sizeof(Areas) / sizeof(tArea));
-    
-    InitPalette();
-    
-    InitScaler();
-
-    CleanDisplay();
-}
-
-tColor cDisplay2BPP::GetColorRGB(enumTeletextColor ttc, int Area) {
-    switch (ttc) {
-    case ttcBlack:       return Background;
-    case ttcRed:         return clrRed;
-    case ttcGreen:       return clrYellow;
-    case ttcYellow:      return clrYellow;
-    case ttcBlue:        return Background;
-    case ttcMagenta:     return clrRed;
-    case ttcCyan:        return clrCyan;
-    case ttcWhite:       return clrCyan;
-    case ttcTransparent: return Background;
-    default:             return Background;
-    }
-}
-
-tColor cDisplay2BPP::GetColorRGBAlternate(enumTeletextColor ttc, int Area) {
-    switch (ttc) {
-    case ttcBlack:       return clrCyan;
-    case ttcRed:         return clrYellow;
-    case ttcGreen:       return clrRed;
-    case ttcYellow:      return clrRed;
-    case ttcBlue:        return clrCyan;
-    case ttcMagenta:     return clrYellow;
-    case ttcCyan:        return Background;
-    case ttcWhite:       return Background;
-    case ttcTransparent: return clrCyan;
-    default:             return Background;
-    }
-}
-
-
-
-
-
-cDisplay4BPP::cDisplay4BPP(int x0, int y0, int width, int height) 
-    : cDisplay(width,height) {
-    // 4BPP display for memory-modded DVB cards and other OSD providers
 
-    osd = cOsdProvider::NewOsd(x0, y0);
-    if (!osd) return;
-   
     width=(width+1)&~1;
     // Width has to end on byte boundary, so round up
 
-    tArea Areas[] = { { 0, 0, width - 1, height - 1, 4 } };
+    tArea Areas[] = { { 0, 0, width - 1, height - 1, 32 } };
     if (osd->CanHandleAreas(Areas, sizeof(Areas) / sizeof(tArea)) != oeOk) {
         DELETENULL(osd);
         return;
-    }   
+    }
     osd->SetAreas(Areas, sizeof(Areas) / sizeof(tArea));
-    
-    InitPalette();
+
+    setOutputWidth(width);
+    setOutputHeight(Height);
+
+#if APIVERSNUM >= 20107
+    Width = 480;
+    Height = 250;
+#endif
+
+    esyslog("OSD-Teletext: 32BPP");
 
     InitScaler();
-    
+
     CleanDisplay();
 }
 
 
-cDisplay4BPPHalf::cDisplay4BPPHalf(int x0, int y0, int width, int height, bool upper) 
+cDisplay32BPPHalf::cDisplay32BPPHalf(int x0, int y0, int width, int height, bool upper)
     : cDisplay(width,height), Upper(upper), OsdX0(x0), OsdY0(y0)
-{   
+{
     osd=NULL;
-    
+
     // Redirect all real init work to method
     InitOSD();
 }
 
-void cDisplay4BPPHalf::InitOSD() {
+void cDisplay32BPPHalf::InitOSD() {
     delete osd;
     osd = cOsdProvider::NewOsd(OsdX0, OsdY0);
     if (!osd) return;
-   
+
     int width=(Width+1)&~1;
     // Width has to end on byte boundary, so round up
-    
-    tArea Areas[] = { { 0, 0, width - 1, Height - 1, 4 } };
+
+    tArea Areas[] = { { 0, 0, width - 1, Height - 1, 32 } };
     // Try full-size area first
-    
+
     while (osd->CanHandleAreas(Areas, sizeof(Areas) / sizeof(tArea)) != oeOk) {
         // Out of memory, so shrink
         if (Upper) {
@@ -218,10 +158,16 @@ void cDisplay4BPPHalf::InitOSD() {
 
     osd->SetAreas(Areas, sizeof(Areas) / sizeof(tArea));
 
-    InitPalette();
+    setOutputWidth(width);
+    setOutputHeight(Height);
+
+#if APIVERSNUM >= 20107
+    Width = 480;
+    Height = 250;
+#endif
 
     InitScaler();
-    
+
     CleanDisplay();
 
     // In case we switched on the fly, do a full redraw
@@ -229,6 +175,3 @@ void cDisplay4BPPHalf::InitOSD() {
     DirtyAll=true;
     Flush();
 }
-
-
-
diff --git a/display.h b/display.h
index 1e21deb..9d6f813 100644
--- a/display.h
+++ b/display.h
@@ -23,12 +23,12 @@ namespace Display {
     // The Display:: namespace mainly encapsulates a cDisplay *display variable
     // and allows NULL-safe access to display members.
     // Additionally, selects via mode the actually used instance for *display.
-    
+
     enum Mode { Full, HalfUpper, HalfLower };
     // Full mode: 2BPP or 4BPP full screen display, depending on memory constrains
     // HalfUpper: 4BPP display of upper half, drop lower half if out of memory
     // HalfLower: 4BPP display of lower half, drop upper half if out of memory
-    
+
     extern Mode mode;
     extern cDisplay *display;
 
@@ -36,40 +36,40 @@ namespace Display {
     void SetMode(Display::Mode mode);
     inline void Delete()
         { if (display) { DELETENULL(display); } }
-    
+
     void ShowUpperHalf();
     // Make sure the upper half of screen is visible
     // eg. for entering numbers etc.
 
 
     // Wrapper calls for various *display members:
-    inline bool GetBlink() 
+    inline bool GetBlink()
         { if (display) return display->GetBlink(); else return false; }
-    inline bool SetBlink(bool blink) 
+    inline bool SetBlink(bool blink)
         { if (display) display->SetBlink(blink); else return false; }
-    inline bool GetConceal() 
+    inline bool GetConceal()
         { if (display) return display->GetConceal(); else return false; }
-    inline bool SetConceal(bool conceal) 
+    inline bool SetConceal(bool conceal)
         { if (display) display->SetConceal(conceal); else return false; }
-    inline cDisplay::enumZoom GetZoom() 
+    inline cDisplay::enumZoom GetZoom()
         { if (display) return display->GetZoom(); else return cDisplay::Zoom_Off; }
     inline void SetZoom(cDisplay::enumZoom zoom)
         { if (display) display->SetZoom(zoom); }
 
     inline void SetBackgroundColor(tColor c)
         { if (display) display->SetBackgroundColor(c); }
-        
-    inline tColor GetBackgroundColor() 
+
+    inline tColor GetBackgroundColor()
         { if (display) return display->GetBackgroundColor(); else return 0; }
 
-    inline void HoldFlush() 
+    inline void HoldFlush()
         { if (display) display->HoldFlush(); }
-    inline void ReleaseFlush() 
+    inline void ReleaseFlush()
         { if (display) display->ReleaseFlush(); }
 
     inline void RenderTeletextCode(unsigned char *PageCode)
         { if (display) display->RenderTeletextCode(PageCode); }
-    
+
     inline void DrawClock()
         { if (display) display->DrawClock(); }
     inline void DrawPageId(const char *text)
@@ -81,51 +81,34 @@ namespace Display {
 }
 
 
-
-
-class cDisplay2BPP : public cDisplay {
-    // 2BPP (4 color) OSD display
-    // Use static color mapping to limit color depth
-    
-public:
-    cDisplay2BPP(int x0, int y0, int width, int height);
-
-    virtual tColor GetColorRGB(enumTeletextColor ttc, int Area);
-    virtual tColor GetColorRGBAlternate(enumTeletextColor ttc, int Area);
-};
-
-
-
-class cDisplay4BPP : public cDisplay {
-    // 4BPP (16 color) OSD display
+class cDisplay32BPP : public cDisplay {
+    // True Color OSD display
     // No need for color mapping
+    // Uses cPixmap instead of cBitmap
 public:
-    cDisplay4BPP(int x0, int y0, int width, int height);
+    cDisplay32BPP(int x0, int y0, int width, int height);
 };
 
 
 
-
-class cDisplay4BPPHalf : public cDisplay {
-    // 4BPP (16 color) OSD display with auto size reduction on memory constrains
+class cDisplay32BPPHalf : public cDisplay {
+    // 32BPP (true color) OSD display with auto size reduction on memory constrains
     // Automatically tries to make visible area as big as possible
     // No need for color mapping
     bool Upper;
     // Prefer to show upper half or lower half?
-    
-    int OsdX0,OsdY0; 
+
+    int OsdX0,OsdY0;
     // Needed to re-initialize osd
 
 public:
-    cDisplay4BPPHalf(int x0, int y0, int width, int height, bool upper);
+    cDisplay32BPPHalf(int x0, int y0, int width, int height, bool upper);
     bool GetUpper() { return Upper; }
-    void SetUpper(bool upper) 
+    void SetUpper(bool upper)
         { if (Upper!=upper) { Upper=upper; InitOSD(); } }
 protected:
     void InitOSD();
 };
 
 
-
-
 #endif
diff --git a/displaybase.c b/displaybase.c
index a65b5d9..bb61058 100644
--- a/displaybase.c
+++ b/displaybase.c
@@ -15,34 +15,78 @@
 
 #include <strings.h>
 #include <time.h>
+#include <vdr/tools.h>
 #include "displaybase.h"
 #include "txtfont.h"
+#include <iostream>
 
+std::string cDisplay::TXTFontFootprint = "";
+int cDisplay::realFontWidths[4] = {0};
 
 cDisplay::cDisplay(int width, int height)
     : Zoom(Zoom_Off), Concealed(false), Blinked(false), FlushLock(0),
       Boxed(false), Width(width), Height(height), Background(clrGray50),
-      osd(NULL), ScaleX(1), ScaleY(1), OffsetX(0), OffsetY(0),
+      osd(NULL), outputWidth(0), outputScaleX(1.0),
+      outputHeight(0), outputScaleY(1.0),
+      ScaleX(1), ScaleY(1), OffsetX(0), OffsetY(0),
       MessageFont(cFont::GetFont(fontSml)), MessageX(0), MessageY(0),
-      MessageW(0), MessageH(0)
+      MessageW(0), MessageH(0),
+      TXTFont(0), TXTDblWFont(0), TXTDblHFont(0), TXTDblHWFont(0)
 {
 }
 
 cDisplay::~cDisplay() {
     DELETENULL(osd);
+    DELETENULL(TXTFont);
+    DELETENULL(TXTDblWFont);
+    DELETENULL(TXTDblHFont);
+    DELETENULL(TXTDblHWFont);
+}
+
+// This is an ugly hack, any ideas on how to get font size with characters (glyphs) of specified width/height?
+cFont *cDisplay::GetFont(const char *name, int fontIndex, int height, int width) {
+    cFont *font = cFont::CreateFont(name, height, width);
+    if (font != NULL) {
+        int realWidth = font->Width('g');
+        if (realWidth > 0) {
+            for (int i = width * width / realWidth; i < width * 4; i++) {
+                DELETENULL(font);
+                font = cFont::CreateFont(name, height, i);
+                if (font != NULL) {
+                    realWidth = font->Width('g');
+                    if (realWidth > width) {
+                        DELETENULL(font);
+                        width = i - 1;
+                        font = cFont::CreateFont(name, height, width);
+                        realFontWidths[fontIndex] = width;
+                        break;
+                    }
+                }
+            }
+        } else {
+            esyslog("OSD-Teletext: font %s returned realWidth of 0 (should not happen, please try a different font)", name);
+        }
+    }
+    isyslog("OSD-Teletext: font %s index %d probed size (w/h) = (%d/%d), char width: %d", name, fontIndex, width, height, font->Width("g"));
+    return font;
+}
+
+std::string cDisplay::GetFontFootprint(const char *name) {
+    return std::string(cString::sprintf("%s_%d_%d_%d", name, fontWidth, fontHeight, Zoom));
 }
 
 void cDisplay::InitScaler() {
     // Set up the scaling factors. Also do zoom mode by
     // scaling differently.
 
-    if (!osd) return;
-    
+    outputScaleX = (double)outputWidth/480.0;
+    outputScaleY = (double)outputHeight/250.0;
+
     int height=Height-6;
     int width=Width-6;
     OffsetX=3;
     OffsetY=3;
-    
+
     switch (Zoom) {
     case Zoom_Upper:
         height=height*2;
@@ -53,42 +97,50 @@ void cDisplay::InitScaler() {
         break;
     default:;
     }
-    
+
     ScaleX=(480<<16)/width;
     ScaleY=(250<<16)/height;
-}
 
-void cDisplay::InitPalette() {
-    cBitmap *bm;
-    if (!osd) return;
+    fontWidth = (outputWidth * 2 / 40) & 0xfffe;
+    if (Zoom == Zoom_Off) {
+        fontHeight = (outputHeight * 2 / 25) & 0xfffe;
+    } else {
+        fontHeight = (outputHeight * 2 / 13) & 0xfffe;
+    }
+    // use even font size for double sized characters (prevents rounding errors during character display)
+    fontWidth &= 0xfffe;
+    fontHeight &= 0xfffe;
 
-    int Area=0;
-    while ((bm=osd->GetBitmap(Area))) {
-        enumTeletextColor c;
-        
-        bm->Reset(); 
-        // reset palette
-        
-        for (c=ttcFirst;c<=ttcLast;c++) bm->Index(GetColorRGB(c,Area));
-        // Announce all palette colors in defined order
-        
-        int x1,y1,x2,y2;
-        if (!bm->Dirty(x1,y1,x2,y2)) {
-            // force bitmap dirty to update palette
-            bm->SetIndex(bm->X0(),bm->Y0(),*bm->Data(bm->X0(),bm->Y0()));
-            // otherwise palette change wont be displayed on flush
-        }
 
-        Area++;
+    isyslog("OSD-Teletext: osd width = %d, height = %d", outputWidth, outputHeight);
+    isyslog("OSD-Teletext: font width * 2 = %d, height = %d", fontWidth, fontHeight);
+
+    int txtFontWidth = fontWidth;
+//    int txtFontHeight = (fontHeight * 17 / 20) & 0xfffe;
+    int txtFontHeight = fontHeight;
+    const char *txtFontName = ttSetup.txtFontName;
+    std::string footprint = GetFontFootprint(txtFontName);
+
+    if (footprint.compare(TXTFontFootprint) == 0) {
+        TXTFont      = cFont::CreateFont(txtFontName, txtFontHeight / 2, realFontWidths[0]);
+        TXTDblWFont  = cFont::CreateFont(txtFontName, txtFontHeight / 2, realFontWidths[1]);
+        TXTDblHFont  = cFont::CreateFont(txtFontName, txtFontHeight, realFontWidths[2]);
+        TXTDblHWFont = cFont::CreateFont(txtFontName, txtFontHeight, realFontWidths[3]);
+    } else {
+        TXTFontFootprint = footprint;
+        TXTFont      = GetFont(txtFontName, 0, txtFontHeight / 2, txtFontWidth / 2);
+        TXTDblWFont  = GetFont(txtFontName, 1, txtFontHeight / 2, txtFontWidth);
+        TXTDblHFont  = GetFont(txtFontName, 2, txtFontHeight, txtFontWidth / 2);
+        TXTDblHWFont = GetFont(txtFontName, 3, txtFontHeight, txtFontWidth);
     }
 }
 
 bool cDisplay::SetBlink(bool blink) {
     int x,y;
     bool Change=false;
-    
+
     if (blink==Blinked) return false;
-    
+
     // touch all blinking chars
     for (y=0;y<25;y++) {
         for (x=0;x<40;x++) {
@@ -100,7 +152,7 @@ bool cDisplay::SetBlink(bool blink) {
     }
     Blinked=blink;
     if (Change) Dirty=true;
-    
+
     Flush();
 
     return Change;
@@ -109,9 +161,9 @@ bool cDisplay::SetBlink(bool blink) {
 bool cDisplay::SetConceal(bool conceal) {
     int x,y;
     bool Change=false;
-    
+
     if (conceal==Concealed) return false;
-    
+
     // touch all concealed chars
     for (y=0;y<25;y++) {
         for (x=0;x<40;x++) {
@@ -123,48 +175,39 @@ bool cDisplay::SetConceal(bool conceal) {
     }
     Concealed=conceal;
     if (Change) Dirty=true;
-    
+
     Flush();
-    
+
     return Change;
 }
 
 void cDisplay::SetZoom(enumZoom zoom) {
-    
+
     if (!osd) return;
     if (Zoom==zoom) return;
     Zoom=zoom;
 
-    // Re-initialize scaler to let zoom take effect 
+    // Re-initialize scaler to let zoom take effect
     InitScaler();
-    
+
     // Clear screen - mainly clear border
     CleanDisplay();
-     
+
     Flush();
 }
 
 void cDisplay::SetBackgroundColor(tColor c) {
     Background=c;
-    InitPalette();
     CleanDisplay();
     Flush();
 }
 
 void cDisplay::CleanDisplay() {
-    cBitmap *bm;
     enumTeletextColor bgc=(Boxed)?(ttcTransparent):(ttcBlack);
-    int Area=0;
-    while ((bm=osd->GetBitmap(Area))) {
-        // Draw rect in two steps to avoid zapping palette
-        bm->DrawRectangle(bm->X0(), bm->Y0()  , bm->X0()+bm->Width()-1, bm->Y0()               , bm->Color(GetColorIndex(bgc,Area)));
-        bm->DrawRectangle(bm->X0(), bm->Y0()+1, bm->X0()+bm->Width()-1, bm->Y0()+bm->Height()-1, bm->Color(GetColorIndex(bgc,Area)));
-        // Yes, this *is* stupid.
-        // Otherwise, ttcTransparent would shift into 0 index of palette,
-        // causing palette re-organization and flicker on page change
-        Area++; 
-    }
-    
+    if (!osd) return;
+
+    osd->DrawRectangle(0, 0, Width, Height, GetColorRGB(bgc,0));
+
     // repaint all
     Dirty=true;
     DirtyAll=true;
@@ -198,9 +241,9 @@ void cDisplay::RenderTeletextCode(unsigned char *PageCode) {
     HoldFlush();
 
     cRenderPage::ReadTeletextHeader(PageCode);
-        
+
     if (!Boxed && (Flags&0x60)!=0) {
-        Boxed=true;     
+        Boxed=true;
         CleanDisplay();
     } else if (Boxed && (Flags&0x60)==0) {
         Boxed=false;
@@ -217,7 +260,7 @@ void cDisplay::RenderTeletextCode(unsigned char *PageCode) {
 void cDisplay::DrawDisplay() {
     int x,y;
     int cnt=0;
-    
+
     if (!IsDirty()) return;
     // nothing to do
 
@@ -262,96 +305,131 @@ inline bool IsPureChar(unsigned int *bitmap) {
 }
 
 
-    
+
 void cDisplay::DrawChar(int x, int y, cTeletextChar c) {
-    unsigned int buffer[10];
-    unsigned int *charmap;
-    cBitmap *bm;
-    
-    // Get character face:
-    charmap=GetFontChar(c,buffer);
-    if (!charmap) {
-        // invalid - clear buffer
-        bzero(&buffer,sizeof buffer);
-        charmap=buffer;
-    }
-    
+    if (!osd) return;
+
     // Get colors
     enumTeletextColor ttfg=c.GetFGColor();
     enumTeletextColor ttbg=c.GetBGColor();
-    
+
     if (c.GetBoxedOut()) {
         ttbg=ttcTransparent;
-        ttfg=ttcTransparent;    
+        ttfg=ttcTransparent;
     }
-        
-    // Virtual box area of the character
-    cBox box;
-    box.SetToCharacter(x,y);
-    
-    // OSD top left pixel of char
-    cVirtualCoordinate TopLeft;
-    TopLeft.VirtualToPixel(this,box.XMin,box.YMin);
-    // This pixel overlaps the box, but may be almost outside.
-    
-    // Move in OSD pixel units until we are inside the box
-    while (TopLeft.VirtX<box.XMin) TopLeft.IncPixelX(this);
-    while (TopLeft.VirtY<box.YMin) TopLeft.IncPixelY(this);
-
-    // Move through all areas
-    int Area=0;
-    while ((bm=osd->GetBitmap(Area))) {
-        cVirtualCoordinate BMTopLeft=TopLeft;
-        
-        // Correct for bitmap offset
-        BMTopLeft.OsdX-=bm->X0();
-        BMTopLeft.OsdY-=bm->Y0();
-    
-        // Map color to local
-        int fg=GetColorIndex(ttfg,Area);
-        int bg=GetColorIndex(ttbg,Area);
-        if (ttfg!=ttbg && fg==bg && !IsPureChar(charmap)) {
-            // Color collision
-            bg=GetColorIndexAlternate(ttbg,Area);
+
+    tColor fg=GetColorRGB(ttfg, 0);
+    tColor bg=GetColorRGB(ttbg, 0);
+
+
+    char buf[5];
+    uint t = GetVTXChar(c);
+    int tl = Utf8CharSet(t, buf);
+    buf[tl] = 0;
+
+    const cFont *font;
+    int charset = c.GetCharset();
+    int fontType = 0;
+    int w = fontWidth / 2;
+    int h = fontHeight / 2;
+    if (c.GetDblWidth() != dblw_Normal) {
+        fontType |= 1;
+        w = fontWidth;
+    }
+
+    if (c.GetDblHeight() != dblh_Normal) {
+        fontType |= 2;
+        h = fontHeight;
+    }
+
+    bool isGraphicsChar;
+    if (charset == CHARSET_GRAPHICS_G1 || charset == CHARSET_GRAPHICS_G1_SEP) {
+        isGraphicsChar = true;
+    } else {
+        isGraphicsChar = false;
+        switch(fontType) {
+            case 0:
+                font = TXTFont;
+                break;
+            case 1:
+                font = TXTDblWFont;
+                break;
+            case 2:
+                font = TXTDblHFont;
+                break;
+            case 3:
+                font = TXTDblHWFont;
+                break;
         }
-    
-        // Now draw the character. Start at the top left corner, and walk
-        // through all pixels on OSD. To speed up, keep one pointer to OSD pixel
-        // and one to virtual box coordinates, and move them together.
-        
-        cVirtualCoordinate p=BMTopLeft;
-        while (p.VirtY<=box.YMax) {
-            // run through OSD lines
-            
-            // OSD line in this bitmap?
-            if (0<=p.OsdY && p.OsdY<bm->Height()) {
-                // bits for this line
+    }
+
+    if (Zoom == Zoom_Lower) {
+        y -=11;
+    }
+
+    int vx = x * fontWidth / 2;
+    int vy = y * fontHeight / 2;
+
+    //~ std::cout << ">> " << std::hex << c.GetC() << "," << t << std::dec << "\t@ " << x << "," << y << "\tfont " << std::hex << c.GetCharset() << "\t" << buf << "\tcolor " << fg << ":" << bg << "\tblink " << c.GetBlink() << "\tdw " << c.GetDblWidth() << "\tdh " << c.GetDblHeight() << "\tbox " << c.GetBoxedOut() << "\tconceal " << c.GetConceal() << std::dec << std::endl;
+    bool drawChar = true;
+    if (c.GetDblWidth() == dblw_Right) {
+        drawChar = false;
+    }
+    if (c.GetDblHeight() == dblh_Bottom) {
+        drawChar = false;
+    }
+
+    if (drawChar) {
+        if (isGraphicsChar) {
+            unsigned int buffer[10];
+            unsigned int *charmap;
+
+            // Get character face:
+            charmap=GetFontChar(c,buffer);
+            if (!charmap) {
+                // invalid - clear buffer
+                bzero(&buffer,sizeof buffer);
+                charmap=buffer;
+            }
+
+            cBitmap charBm(w, h, 24);
+            charBm.DrawRectangle(0, 0, w, h, bg);
+
+            // draw scaled graphics char
+            int virtY = 0;
+            while (virtY<=h) {
                 int bitline;
-                bitline=charmap[(p.VirtY-box.YMin)>>16];
-        
-                p.OsdX=BMTopLeft.OsdX;
-                p.VirtX=BMTopLeft.VirtX;
-                while (p.VirtX<=box.XMax) {
-                    // run through line pixels
-                    
-                    // pixel insied this bitmap?
-                    if (0<=p.OsdX && p.OsdX<bm->Width()) {
-                        // pixel offset in bitline:
-                        int bit=(p.VirtX-box.XMin)>>16;
-                        
-                        if (bitline&(0x8000>>bit)) {
-                            bm->SetIndex(p.OsdX,p.OsdY,fg);
-                        } else {
-                            bm->SetIndex(p.OsdX,p.OsdY,bg);
-                        }
+                bitline=charmap[virtY * 10 / h];
+
+                int virtX=0;
+                while (virtX < w) {
+                    int bit=(virtX * 12 / w);
+                    if (bitline&(0x8000>>bit)) {
+                        charBm.DrawPixel(virtX,virtY,fg);
+//                    } else {
+//                        charBm.DrawPixel(virtX,virtY,bg);
                     }
-                    p.IncPixelX(this);
+                    virtX++;
                 }
+                virtY++;
             }
-            p.IncPixelY(this);
+
+            osd->DrawBitmap(vx, vy, charBm);
+        } else {
+#if 0
+            // hi level osd devices (e.g. rpi and softhddevice openglosd currently do not support monospaced fonts with arbitrary width
+//            osd->DrawRectangle(vx, vy, vx + w - 1, vy + h - 1, bg);
+            osd->DrawText(vx, vy, buf, fg, bg, font);
+#else
+            cBitmap charBm(w, h, 24);
+            charBm.DrawRectangle(0, 0, w, h, bg);
+//            charBm.DrawText(0, 0, buf, fg, bg, font);
+            charBm.DrawText(0, 0, buf, fg, 0, font);
+            osd->DrawBitmap(vx, vy, charBm);
+#endif
         }
-        Area++;
     }
+
 }
 
 void cDisplay::DrawText(int x, int y, const char *text, int len) {
@@ -370,7 +448,7 @@ void cDisplay::DrawText(int x, int y, const char *text, int len) {
         x++;
         len--;
     }
-    
+
     // Fill remaining chars with spaces
     c.SetChar(' ');
     while (len>0) {
@@ -386,7 +464,7 @@ void cDisplay::DrawClock() {
     char text[9];
     time_t t=time(0);
     struct tm loct;
-    
+
     localtime_r(&t, &loct);
     sprintf(text, "%02d:%02d:%02d", loct.tm_hour, loct.tm_min, loct.tm_sec);
 
@@ -395,45 +473,38 @@ void cDisplay::DrawClock() {
 
 void cDisplay::DrawMessage(const char *txt) {
     const int border=5;
-    cBitmap *bm;
-    
+
     if (!osd) return;
-    
+
     HoldFlush();
     // Hold flush until done
-    
+
     ClearMessage();
     // Make sure old message is gone
-    
+
     if (IsDirty()) DrawDisplay();
     // Make sure all characters are out, so we can draw on top
-    
+
     int w=MessageFont->Width(txt)+4*border;
     int h=MessageFont->Height(txt)+4*border;
-    int x=(Width-w)/2;
-    int y=(Height-h)/2;
-
-    int Area=0;
-    while ((bm=osd->GetBitmap(Area))) {
-        // Walk through all OSD areas
-
-        // Get local color mapping      
-        tColor fg=bm->Color(GetColorIndex(ttcWhite,Area));
-        tColor bg=bm->Color(GetColorIndex(ttcBlack,Area));
-        if (fg==bg) bg=bm->Color(GetColorIndexAlternate(ttcBlack,Area));
-        
-        // Draw framed box
-        bm->DrawRectangle(x         ,y         ,x+w-1       ,y+border-1  ,fg);
-        bm->DrawRectangle(x         ,y+h-border,x+w-1       ,y+h-1       ,fg);
-        bm->DrawRectangle(x         ,y         ,x+border-1  ,y+h-1       ,fg);
-        bm->DrawRectangle(x+w-border,y         ,x+w-1       ,y+h-1       ,fg);
-        bm->DrawRectangle(x+border  ,y+border  ,x+w-border-1,y+h-border-1,bg);
-
-        // Draw text
-        bm->DrawText(x+2*border,y+2*border,txt, fg, bg, MessageFont);
-
-        Area++;
-    }
+    int x=(outputWidth-w)/2;
+    int y=(outputHeight-h)/2;
+
+    // Get local color mapping
+    tColor fg=GetColorRGB(ttcWhite,0);
+    tColor bg=GetColorRGB(ttcBlack,0);
+    if (fg==bg) bg=GetColorRGBAlternate(ttcBlack,0);
+
+    // Draw framed box
+    osd->DrawRectangle(x         ,y         ,x+w-1       ,y+border-1  ,fg);
+    osd->DrawRectangle(x         ,y+h-border,x+w-1       ,y+h-1       ,fg);
+    osd->DrawRectangle(x         ,y         ,x+border-1  ,y+h-1       ,fg);
+    osd->DrawRectangle(x+w-border,y         ,x+w-1       ,y+h-1       ,fg);
+    osd->DrawRectangle(x+border  ,y+border  ,x+w-border-1,y+h-border-1,bg);
+
+    // Draw text
+    osd->DrawText(x+2*border,y+2*border,txt, fg, bg, MessageFont);
+
 
     // Remember box
     MessageW=w;
@@ -448,29 +519,27 @@ void cDisplay::DrawMessage(const char *txt) {
 void cDisplay::ClearMessage() {
     if (!osd) return;
     if (MessageW==0 || MessageH==0) return;
-    
+
     // map OSD pixel to virtual coordinate, use center of pixel
     int x0=(MessageX-OffsetX)*ScaleX+ScaleX/2;
     int y0=(MessageY-OffsetY)*ScaleY+ScaleY/2;
     int x1=(MessageX+MessageW-1-OffsetX)*ScaleX+ScaleX/2;
     int y1=(MessageY+MessageH-1-OffsetY)*ScaleY+ScaleY/2;
-    
+
     // map to character
     x0=x0/(12<<16);
     y0=y0/(10<<16);
     x1=(x1+(12<<16)-1)/(12<<16);
     y1=(y1+(10<<16)-1)/(10<<16);
-    
+
     for (int x=x0;x<=x1;x++) {
         for (int y=y0;y<=y1;y++) {
             MakeDirty(x,y);
         }
     }
-    
+
     MessageW=0;
     MessageH=0;
-    
+
     Flush();
 }
-
-
diff --git a/displaybase.h b/displaybase.h
index c85f3a3..91c3e95 100644
--- a/displaybase.h
+++ b/displaybase.h
@@ -17,14 +17,16 @@
 #define OSDTELETEXT_DISPLAYBASE_H_
 
 #include "txtrender.h"
+#include "setup.h"
 #include <vdr/osd.h>
+#include <string>
 
 class cDisplay : public cRenderPage {
     // Class that extends the virtual cRenderPage with the capability
     // to render its contents to an OSD of variable size.
     // Renders incrementally - just changes
     // plus adds some more display features like message display.
-    
+
 public:
     enum enumZoom {
         // Zoom up upper/lower half of page
@@ -36,34 +38,49 @@ public:
 protected:
     bool Concealed;
     // Hidden text internal state
-    
+
     bool Blinked;
     // Blinking text internal state
-    
+
     int FlushLock;
     // Lock counter for bundeling OSD flushes
-    
+
     bool Boxed;
     // Page is 'boxed mode' transparent
-    
+
     int Width;
     int Height;
     // OSD pixel dimension
-    
+
     tColor Background;
     // Color to be used for black background
     // - allow transparency
 
     cOsd *osd;
     // The osd object. If creation fails, may be NULL
-    
+
+    int outputWidth;
+    double outputScaleX;
+    int outputHeight;
+    double outputScaleY;
+    // for 32bpp true color, If creation fails, may be NULL
+
     int ScaleX,ScaleY;
     int OffsetX,OffsetY;
     // Virtual coordinate system, see InitScaler
-    
+
     const cFont *MessageFont;
     int MessageX,MessageY,MessageW,MessageH;
-    // Message overlay window, position and font
+
+    const cFont *TXTFont;
+    const cFont *TXTDblWFont;
+    const cFont *TXTDblHFont;
+    const cFont *TXTDblHWFont;
+    int fontHeight;
+    int fontWidth;
+
+    static int realFontWidths[4];
+
 
     class cBox {
         // helper class. Represents a character's box in virtual coordinates
@@ -72,7 +89,7 @@ protected:
         inline void SetToCharacter(int x, int y);
     };
     friend class cBox;
-    
+
     class cVirtualCoordinate {
         // helper class. Represents a coordinate in virtual display space
         // and in OSD pixel coordinates.
@@ -84,26 +101,32 @@ protected:
         inline void IncPixelY(cDisplay *Display);
     };
     friend class cVirtualCoordinate;
-    
+
 public:
     cDisplay(int width, int height);
     virtual ~cDisplay();
     bool Valid() { return (osd!=NULL); }
     // After creation, check for Valid(). Destroy, if not valid.
-        
-protected:  
+
+    void setOutputWidth(int w) { outputWidth = w; };
+    void setOutputHeight(int h) { outputHeight = h; };
+
+    static std::string GFXFontFootprint;
+    static std::string TXTFontFootprint;
+
+protected:
     void InitScaler();
     // Initialize transformation for OSD->Virtual coordinates
     // Some words about scaling:
-    
+
     // OSD display is variable width x height, with 3 pixels border
     // on all sides. There is a virtual coordinate system projected
-    // on this, with (3,3) mapped to (0,0) and (width-3,height-3) 
+    // on this, with (3,3) mapped to (0,0) and (width-3,height-3)
     // mapped to (480<<16,250<<16).
     // The idea is, that each font pixel uses a virtual rectangle
     // of (1<<16,1<<16) size.
-    
-    // ScaleX,ScaleY represent the (virtual) width and height of a 
+
+    // ScaleX,ScaleY represent the (virtual) width and height of a
     // physical OSD pixel.
     // OffsetX,OffsetY default to 3,3 to represent the border offset,
     // but may be used differently.
@@ -113,12 +136,12 @@ public:
     bool SetBlink(bool blink);
     // Switch blink frequently to get blinking chars
     // Returns true if there are blinking characters.
-    
+
     bool GetConceal() { return Concealed; }
     bool SetConceal(bool conceal);
     // Hidden text. Set to true to see hidden text.
     // Returns true if there are concealed characters.
-    
+
     enumZoom GetZoom() { return Zoom; }
     void SetZoom(enumZoom zoom);
     // Zoom to upper/lower half of page
@@ -136,45 +159,25 @@ public:
     // Map this teletext color to an OSD color in #Area, but dont
     // return same as GetColorRGB(). Used to solve conflicts if
     // foreground and background are mapped to same color.
-    // Defaults to 1:1 identity. Not needed if all colors actually 
+    // Defaults to 1:1 identity. Not needed if all colors actually
     // supported by OSD.
 
-    int GetColorIndex(enumTeletextColor ttc, int Area) {
-        // Map this teletext color to an OSD color index in #Area.
-        if (!osd) return 0;
-        cBitmap *bm=osd->GetBitmap(Area);
-        if (!bm) return 0;
-        return bm->Index(GetColorRGB(ttc,Area));
-    }
-        
-    int GetColorIndexAlternate(enumTeletextColor ttc, int Area) {
-        // Map this teletext color to an OSD color index in #Area.
-        if (!osd) return 0;
-        cBitmap *bm=osd->GetBitmap(Area);
-        if (!bm) return 0;
-        return bm->Index(GetColorRGBAlternate(ttc,Area));
-    }
-
-        
-    
 protected:
-    void InitPalette();
-    // Initialize palette(s) for OSD
 
     void DrawDisplay();
     // Draw all dirty characters from cRenderPage buffer to OSD
-    
+
     void CleanDisplay();
     // Clean OSD completely
-    
+
     virtual void DrawChar(int x, int y, cTeletextChar c);
     // Draw a single character to OSD
-    
+
 
 public:
     void HoldFlush() { FlushLock++; }
     // Hold all OSD flush updates to bundle operations.
-    
+
     void ReleaseFlush() { FlushLock--; Flush(); }
     // Release hold of flush updates. After last release,
     // the flush will be done
@@ -184,14 +187,13 @@ protected:
         // Commit all changes from OSD internal bitmaps to device
         // All draw operations inside cDisplay should call it,
         // no one outside should need to call it.
-        
         if (FlushLock>0) return;
         if (!osd) return;
         if (IsDirty()) DrawDisplay();
         osd->Flush();
     }
 
-public: 
+public:
     void RenderTeletextCode(unsigned char *PageCode);
     // Interprete teletext code referenced by PageCode
     // and draw the whole page content into OSD.
@@ -200,19 +202,24 @@ public:
     void DrawText(int x, int y, const char *text, int len);
     // Draw some characters in teletext page.
     // Max len chars, fill up with spaces
-    
+
     void DrawClock();
     // Draw current time to OSD
-    
-    void DrawPageId(const char *text)   
+
+    void DrawPageId(const char *text)
         { DrawText(0,0,text,8); }
-    // Draw Page ID string to OSD   
-        
+    // Draw Page ID string to OSD
+
     void DrawMessage(const char *txt);
     // Draw a framed, centered message box to OSD
-    
+
     void ClearMessage();
     // Remove message box and redraw hidden content
+
+
+private:
+    cFont *GetFont(const char *name, int index, int height, int width);
+    std::string GetFontFootprint(const char *name);
 };
 
 
@@ -226,10 +233,10 @@ inline void cDisplay::cBox::SetToCharacter(int x, int y) {
 }
 
 inline void cDisplay::cVirtualCoordinate::VirtualToPixel(cDisplay *Display, int x, int y) {
-    // Map virtual coordinate to OSD pixel  
+    // Map virtual coordinate to OSD pixel
     OsdX=x/Display->ScaleX+Display->OffsetX;
     OsdY=y/Display->ScaleY+Display->OffsetY;
-    
+
     // map OSD pixel back to virtual coordinate, use center of pixel
     VirtX=(OsdX-Display->OffsetX)*Display->ScaleX+Display->ScaleX/2;
     VirtY=(OsdY-Display->OffsetY)*Display->ScaleY+Display->ScaleY/2;
diff --git a/menu.c b/menu.c
index 79f04e1..795b133 100644
--- a/menu.c
+++ b/menu.c
@@ -7,10 +7,10 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-  
+
 #include <map>
 #include <time.h>
-    
+
 #include <vdr/interface.h>
 #include <vdr/config.h>
 
@@ -30,7 +30,7 @@
 #define PSEUDO_HEX_TO_DECIMAL(x) ( (GET_HUNDREDS_DECIMAL(x))*256 + (GET_TENS_DECIMAL(x))*16 + (GET_ONES_DECIMAL(x)) )
 
 using namespace std;
-   
+
 int Stretch = true;
 typedef map<int,int> IntMap;
 IntMap channelPageMap;
@@ -73,35 +73,45 @@ void TeletextBrowser::Show(void) {
 }
 
 bool TeletextBrowser::CheckIsValidChannel(int number) {
-   return (Channels.GetByNumber(number) != 0);
+#if APIVERSNUM >= 20301
+    LOCK_CHANNELS_READ;
+    return (Channels->GetByNumber(number) != 0);
+#else
+    return (Channels.GetByNumber(number) != 0);
+#endif
 }
 
 void TeletextBrowser::ChannelSwitched(int ChannelNumber) {
+#if APIVERSNUM >= 20301
+   LOCK_CHANNELS_READ;
+   const cChannel *chan=Channels->GetByNumber(ChannelNumber);
+#else
    cChannel *chan=Channels.GetByNumber(ChannelNumber);
-   
+#endif
+
    if (!chan)
       return;
-      
+
    tChannelID chid=chan->GetChannelID();
    if (chid==channel || chid==tChannelID::InvalidID)
       return;
-      
+
    channel=chid;
-   
+
    //store page number of current channel
    IntMap::iterator it;
    channelPageMap[currentChannelNumber] = currentPage;
    currentChannelNumber=ChannelNumber;
-   
+
    currentPage=0x100;
    currentSubPage=0;
-      
+
    //see if last page number on this channel was stored
    it=channelPageMap.find(ChannelNumber);
    if (it != channelPageMap.end()) { //found
       currentPage=(*it).second;
    }
-   
+
    //on the one hand this must work in background mode, when the plugin is not active.
    //on the other hand, if active, the page should be shown.
    //so this self-Pointer.
@@ -114,7 +124,7 @@ void TeletextBrowser::ChannelSwitched(int ChannelNumber) {
 eOSState TeletextBrowser::ProcessKey(eKeys Key) {
    if (Key != kNone)
       lastActivity = time(NULL);
-   
+
    switch (Key) {
       case k1: SetNumber(1);break;
       case k2: SetNumber(2);break;
@@ -125,7 +135,7 @@ eOSState TeletextBrowser::ProcessKey(eKeys Key) {
       case k7: SetNumber(7);break;
       case k8: SetNumber(8);break;
       case k9: SetNumber(9);break;
-      case k0: 
+      case k0:
          //same behavior for 0 as VDR does it with channels
          if ((cursorPos==0)  && (!selectingChannel)) {
             //swap variables
@@ -139,7 +149,7 @@ eOSState TeletextBrowser::ProcessKey(eKeys Key) {
          } else
             SetNumber(0);
          break;
-      case kOk: 
+      case kOk:
          if (selectingChannel) {
             selectingChannel=false;
             Display::ClearMessage();
@@ -154,8 +164,8 @@ eOSState TeletextBrowser::ProcessKey(eKeys Key) {
                ShowPage();
             }
          }
-         break;        
-      case kBack: return osEnd; 
+         break;
+      case kBack: return osEnd;
       case kNone: //approx. every second
          //checking if page changed
          if ( pageFound && ttSetup.autoUpdatePage && cursorPos==0 && !selectingChannel && (PageCheckSum() != checkSum) ) {
@@ -201,7 +211,7 @@ eOSState TeletextBrowser::ProcessKey(eKeys Key) {
          ChangePageRelative(DirectionBackward);
          Display::ShowUpperHalf();
          ShowPage();
-         break;       
+         break;
       case kRight:
          if (selectingChannel) {
              selectingChannel=false;
@@ -214,7 +224,7 @@ eOSState TeletextBrowser::ProcessKey(eKeys Key) {
          ChangeSubPageRelative(DirectionForward);
          Display::ShowUpperHalf();
          ShowPage();
-         break;       
+         break;
       case kLeft:
          if (selectingChannel) {
              selectingChannel=false;
@@ -228,11 +238,11 @@ eOSState TeletextBrowser::ProcessKey(eKeys Key) {
          ChangeSubPageRelative(DirectionBackward);
          Display::ShowUpperHalf();
          ShowPage();
-         break; 
-         
-              
-      case kRed: 
-      case kGreen: 
+         break;
+
+
+      case kRed:
+      case kGreen:
       case kBlue:
       case kYellow:
       //case kUser1:case kUser2:case kUser3:case kUser4:case kUser5:
@@ -243,7 +253,7 @@ eOSState TeletextBrowser::ProcessKey(eKeys Key) {
             SetNumber(-3);
          }
          ExecuteAction(TranslateKey(Key));
-         break;             
+         break;
       default: break;
    }
    return osContinue;
@@ -256,7 +266,7 @@ void TeletextBrowser::ExecuteAction(eTeletextAction e) {
                    selectingChannel=false;
                    Display::ClearMessage();
                }
-               
+
                switch (Display::GetZoom()) {
                case cDisplay::Zoom_Off:
                   Display::SetZoom(cDisplay::Zoom_Upper);
@@ -268,14 +278,14 @@ void TeletextBrowser::ExecuteAction(eTeletextAction e) {
                   Display::SetZoom(cDisplay::Zoom_Off);
                   break;
                }
-               
+
                break;
             case HalfPage:
                if (selectingChannel) {
                    selectingChannel=false;
                    Display::ClearMessage();
                }
-                  
+
                switch (Display::mode) {
                case Display::HalfUpper:
                   Display::SetMode(Display::HalfLower);
@@ -322,7 +332,7 @@ void TeletextBrowser::ExecuteAction(eTeletextAction e) {
                   currentPage=pageNr;
                   cursorPos=0;
                   currentSubPage=0;
-                  
+
                   Display::ShowUpperHalf();
                   ShowPage();
                }
@@ -371,11 +381,11 @@ eTeletextAction TeletextBrowser::TranslateKey(eKeys Key) {
 void TeletextBrowser::SetNumber(int i) {
    //cursorPos means insertion after, 0<=cursorPos<=2
    if (selectingChannel) {
-      selectingChannelNumber = selectingChannelNumber*10+i;  
+      selectingChannelNumber = selectingChannelNumber*10+i;
       ShowAskForChannel();
       return;
    }
-   
+
    //i<0 means revert cursor position
    if (i<0) {
       for (;i<0;i++) {
@@ -395,7 +405,7 @@ void TeletextBrowser::SetNumber(int i) {
       return;
    }
 
-   
+
    static int tempPage;
    switch (cursorPos) {
    case 0:
@@ -505,19 +515,19 @@ bool TeletextBrowser::CheckFirstSubPage(int startWith) {
          return true;
       //currentSubPage++;
       currentSubPage=nextValidPageNumber(currentSubPage, DirectionForward);
-      
+
       if (currentSubPage > 0x99) currentSubPage=0;
       if (currentSubPage < 0) currentSubPage=0x99;
 
    } while (currentSubPage != oldsubpage);
-   
+
    return false;
 }
 
 bool TeletextBrowser::CheckPage()
 {
    StorageHandle fd;
-   
+
    if (!(fd=storage->openForReading(PageID(channel, currentPage, currentSubPage), false)) )
       return false;
 
@@ -577,12 +587,12 @@ bool TeletextBrowser::DecodePage() {
          storage->close(fd);
       }
    }
-   
+
    if ( (fd=storage->openForReading(PageID(channel, currentPage, currentSubPage), true)) )
    {
       storage->read(cache,sizeof cache,fd); // Read full page data
       storage->close(fd);
-      
+
       Display::HoldFlush();
       Display::ClearMessage();
       Display::RenderTeletextCode(cache);
@@ -610,9 +620,9 @@ bool TeletextBrowser::DecodePage() {
 int TeletextBrowser::PageCheckSum() {
    int retSum=0;
    StorageHandle fd;
-   
+
    CheckFirstSubPage(currentSubPage);
-   
+
    if ((fd=storage->openForReading(PageID(channel, currentPage, currentSubPage), false)) ) {
       uchar cache[960];
       storage->read(cache, 12, fd); //skip
@@ -643,13 +653,13 @@ TeletextSetup::TeletextSetup()
     //because there is no advantage, but a possible problem when VDR's value is change
     //after the plugin has stored its own value.
     inactivityTimeout(Setup.MinUserInactivity),
-    HideMainMenu(false)
+    HideMainMenu(false),
+    txtFontName("FreeMono:Standard")
 {
    //init key bindings
    for (int i=0;i<10;i++)
       mapKeyToAction[0]=(eTeletextAction)0;
    mapKeyToAction[3]=Zoom;
-   mapKeyToAction[2]=HalfPage;   
+   mapKeyToAction[2]=HalfPage;
    mapKeyToAction[0]=SwitchChannel;
 }
-
diff --git a/osdteletext.c b/osdteletext.c
index 2cd772a..e2dadf1 100644
--- a/osdteletext.c
+++ b/osdteletext.c
@@ -14,6 +14,7 @@
 #include <vdr/config.h>
 
 #include <getopt.h>
+#include <iostream>
 
 using namespace std;
 
@@ -272,6 +273,7 @@ bool cPluginTeletextosd::SetupParse(const char *Name, const char *Value)
   else if (!strcasecmp(Name, "OSDVAlign")) ttSetup.OSDVAlign=atoi(Value);
   else if (!strcasecmp(Name, "inactivityTimeout")) /*ttSetup.inactivityTimeout=atoi(Value)*/;
   else if (!strcasecmp(Name, "HideMainMenu")) ttSetup.HideMainMenu=atoi(Value);
+  else if (!strcasecmp(Name, "txtFontName")) ttSetup.txtFontName=strdup(Value);
   else {
      for (int i=0;i<LastActionKey;i++) {
         if (!strcasecmp(Name, cTeletextSetupPage::actionKeyNames[i].internalName)) {
@@ -313,7 +315,9 @@ void cTeletextSetupPage::Store(void) {
    ttSetup.OSDHAlign=temp.OSDHAlign;
    ttSetup.OSDVAlign=temp.OSDVAlign;
    ttSetup.HideMainMenu=temp.HideMainMenu;
+   ttSetup.txtFontName=temp.txtFontNames[temp.txtFontIndex];
    //ttSetup.inactivityTimeout=temp.inactivityTimeout;
+   std::cout << "store " << (const char *)temp.txtFontName << " " << temp.txtFontIndex << std::endl;
    
    for (int i=0;i<LastActionKey;i++) {
       SetupStore(actionKeyNames[i].internalName, ttSetup.mapKeyToAction[i]);
@@ -328,6 +332,7 @@ void cTeletextSetupPage::Store(void) {
    SetupStore("OSDHAlign", ttSetup.OSDHAlign);
    SetupStore("OSDVAlign", ttSetup.OSDVAlign);
    SetupStore("HideMainMenu", ttSetup.HideMainMenu);
+   SetupStore("txtFontName", ttSetup.txtFontName);
    //SetupStore("inactivityTimeout", ttSetup.inactivityTimeout);
 }
 
@@ -355,8 +360,16 @@ cTeletextSetupPage::cTeletextSetupPage(void) {
    temp.OSDHAlign=ttSetup.OSDHAlign;
    temp.OSDVAlign=ttSetup.OSDVAlign;
    temp.HideMainMenu=ttSetup.HideMainMenu;
+   temp.txtFontName=ttSetup.txtFontName;
    //temp.inactivityTimeout=ttSetup.inactivityTimeout;
 
+   cFont::GetAvailableFontNames(&temp.txtFontNames, true);
+   temp.txtFontIndex = temp.txtFontNames.Find(ttSetup.txtFontName);
+   if (temp.txtFontIndex < 0) {
+       temp.txtFontIndex = 0;
+   }
+
+
    Add(new cMenuEditIntItem(tr("Background transparency"), &tempConfiguredClrBackground, 0, 255)); 
    
    Add(new cMenuEditBoolItem(tr("Show clock"), &temp.showClock ));
@@ -371,6 +384,7 @@ cTeletextSetupPage::cTeletextSetupPage(void) {
    Add(new cMenuEditIntItem(tr("OSD horizontal align"), &temp.OSDHAlign, 0, 100));
    Add(new cMenuEditIntItem(tr("OSD vertical align"), &temp.OSDVAlign, 0, 100));
    Add(new cMenuEditBoolItem(tr("Hide mainmenu entry"), &temp.HideMainMenu));
+   Add(new cMenuEditStraItem(tr("Text Font"), &temp.txtFontIndex, temp.txtFontNames.Size(), &temp.txtFontNames[0]));
    
    //Using same string as VDR's setup menu
    //Add(new cMenuEditIntItem(tr("Setup.Miscellaneous$Min. user inactivity (min)"), &temp.inactivityTimeout));
diff --git a/po/ca_ES.po b/po/ca_ES.po
index bfa9d13..49e9ba3 100644
--- a/po/ca_ES.po
+++ b/po/ca_ES.po
@@ -9,7 +9,7 @@ msgid ""
 msgstr ""
 "Project-Id-Version: VDR 1.5.7\n"
 "Report-Msgid-Bugs-To: <see README>\n"
-"POT-Creation-Date: 2013-03-10 17:21+0100\n"
+"POT-Creation-Date: 2016-02-17 21:25+0100\n"
 "PO-Revision-Date: 2008-05-04 15:33+0200\n"
 "Last-Translator: Jordi Vilà <jvila@tinet.org>\n"
 "Language-Team: Catalan <vdr@linuxtv.org>\n"
@@ -72,6 +72,9 @@ msgstr ""
 msgid "Hide mainmenu entry"
 msgstr ""
 
+msgid "Text Font"
+msgstr ""
+
 msgid "Key bindings"
 msgstr ""
 
diff --git a/po/de_DE.po b/po/de_DE.po
index 60a73e4..d3c4bbc 100644
--- a/po/de_DE.po
+++ b/po/de_DE.po
@@ -7,7 +7,7 @@ msgid ""
 msgstr ""
 "Project-Id-Version: VDR 1.5.7\n"
 "Report-Msgid-Bugs-To: <see README>\n"
-"POT-Creation-Date: 2013-03-10 17:21+0100\n"
+"POT-Creation-Date: 2016-02-17 21:25+0100\n"
 "PO-Revision-Date: 2008-05-04 15:33+0200\n"
 "Last-Translator: Klaus Schmidinger <Klaus.Schmidinger@tvdr.de>\n"
 "Language-Team: German <vdr@linuxtv.org>\n"
@@ -70,6 +70,9 @@ msgstr "OSD vertikale Anordnung"
 msgid "Hide mainmenu entry"
 msgstr "Hauptmenüeintrag verstecken"
 
+msgid "Text Font"
+msgstr ""
+
 msgid "Key bindings"
 msgstr "Tastenzuweisung"
 
diff --git a/po/es_ES.po b/po/es_ES.po
index b7e476d..9e373f4 100644
--- a/po/es_ES.po
+++ b/po/es_ES.po
@@ -7,7 +7,7 @@ msgid ""
 msgstr ""
 "Project-Id-Version: VDR 1.5.7\n"
 "Report-Msgid-Bugs-To: <see README>\n"
-"POT-Creation-Date: 2013-03-10 17:21+0100\n"
+"POT-Creation-Date: 2016-02-17 21:25+0100\n"
 "PO-Revision-Date: 2008-05-04 15:33+0200\n"
 "Last-Translator: Ruben Nunez Francisco <ruben.nunez@tang-it.com>\n"
 "Language-Team: Spanish <vdr@linuxtv.org>\n"
@@ -70,6 +70,9 @@ msgstr ""
 msgid "Hide mainmenu entry"
 msgstr ""
 
+msgid "Text Font"
+msgstr ""
+
 msgid "Key bindings"
 msgstr ""
 
diff --git a/po/fi_FI.po b/po/fi_FI.po
index 3d2b32a..5b88212 100644
--- a/po/fi_FI.po
+++ b/po/fi_FI.po
@@ -7,7 +7,7 @@ msgid ""
 msgstr ""
 "Project-Id-Version: VDR 1.5.7\n"
 "Report-Msgid-Bugs-To: <see README>\n"
-"POT-Creation-Date: 2013-03-10 17:21+0100\n"
+"POT-Creation-Date: 2016-02-17 21:25+0100\n"
 "PO-Revision-Date: 2008-05-04 15:33+0200\n"
 "Last-Translator: Rolf Ahrenberg <rahrenbe@cc.hut.fi>\n"
 "Language-Team: Finnish <vdr@linuxtv.org>\n"
@@ -70,6 +70,9 @@ msgstr "Vaakakeskitys"
 msgid "Hide mainmenu entry"
 msgstr "Piilota valinta päävalikosta"
 
+msgid "Text Font"
+msgstr ""
+
 msgid "Key bindings"
 msgstr "Näppäintoiminnot"
 
diff --git a/po/fr_FR.po b/po/fr_FR.po
index 1c74bf0..9745603 100644
--- a/po/fr_FR.po
+++ b/po/fr_FR.po
@@ -10,7 +10,7 @@ msgid ""
 msgstr ""
 "Project-Id-Version: VDR 1.5.7\n"
 "Report-Msgid-Bugs-To: <see README>\n"
-"POT-Creation-Date: 2013-03-10 17:21+0100\n"
+"POT-Creation-Date: 2016-02-17 21:25+0100\n"
 "PO-Revision-Date: 2009-01-10 19:32+0100\n"
 "Last-Translator: Nival Michaël\n"
 "Language-Team: French <vdr@linuxtv.org>\n"
@@ -73,6 +73,9 @@ msgstr "Alignement vertical de l'OSD"
 msgid "Hide mainmenu entry"
 msgstr ""
 
+msgid "Text Font"
+msgstr ""
+
 msgid "Key bindings"
 msgstr "Attribution des touches"
 
diff --git a/po/it_IT.po b/po/it_IT.po
index fb496ba..80e5622 100644
--- a/po/it_IT.po
+++ b/po/it_IT.po
@@ -11,7 +11,7 @@ msgid ""
 msgstr ""
 "Project-Id-Version: VDR 1.5.7\n"
 "Report-Msgid-Bugs-To: <see README>\n"
-"POT-Creation-Date: 2013-03-10 17:21+0100\n"
+"POT-Creation-Date: 2016-02-17 21:25+0100\n"
 "PO-Revision-Date: 2010-11-06 19:59+0100\n"
 "Last-Translator: Diego Pierotto <vdr-italian@tiscali.it>\n"
 "Language-Team: Italian <vdr@linuxtv.org>\n"
@@ -77,6 +77,9 @@ msgstr "Allineamento verticale OSD"
 msgid "Hide mainmenu entry"
 msgstr "Nascondi voce menu principale"
 
+msgid "Text Font"
+msgstr ""
+
 msgid "Key bindings"
 msgstr "Tasti associati"
 
diff --git a/po/pt_PT.po b/po/pt_PT.po
index 70537e0..d8e8336 100644
--- a/po/pt_PT.po
+++ b/po/pt_PT.po
@@ -7,7 +7,7 @@ msgid ""
 msgstr ""
 "Project-Id-Version: VDR 1.5.7\n"
 "Report-Msgid-Bugs-To: <see README>\n"
-"POT-Creation-Date: 2013-03-10 17:21+0100\n"
+"POT-Creation-Date: 2016-02-17 21:25+0100\n"
 "PO-Revision-Date: 2008-05-04 15:33+0200\n"
 "Last-Translator: Chris Silva <hudokkow@gmail.com>\n"
 "Language-Team: Portuguese <vdr@linuxtv.org>\n"
@@ -70,6 +70,9 @@ msgstr "Alinhamento Vertical do OSD"
 msgid "Hide mainmenu entry"
 msgstr ""
 
+msgid "Text Font"
+msgstr ""
+
 msgid "Key bindings"
 msgstr "Tecla alocada"
 
diff --git a/po/ru_RU.po b/po/ru_RU.po
index 3ea7877..aeb07ad 100644
--- a/po/ru_RU.po
+++ b/po/ru_RU.po
@@ -7,7 +7,7 @@ msgid ""
 msgstr ""
 "Project-Id-Version: VDR 1.5.7\n"
 "Report-Msgid-Bugs-To: <see README>\n"
-"POT-Creation-Date: 2013-03-10 17:21+0100\n"
+"POT-Creation-Date: 2016-02-17 21:25+0100\n"
 "PO-Revision-Date: 2008-12-30 13:52+0100\n"
 "Last-Translator: Oleg Roitburd <oleg@roitburd.de>\n"
 "Language-Team: Russian <vdr@linuxtv.org>\n"
@@ -71,6 +71,9 @@ msgstr "Вертикальное положение OSD"
 msgid "Hide mainmenu entry"
 msgstr ""
 
+msgid "Text Font"
+msgstr ""
+
 msgid "Key bindings"
 msgstr "Привязка кнопок"
 
diff --git a/po/sk_SK.po b/po/sk_SK.po
index 8f8fa7d..5bf267f 100644
--- a/po/sk_SK.po
+++ b/po/sk_SK.po
@@ -7,7 +7,7 @@ msgid ""
 msgstr ""
 "Project-Id-Version: osdteletext-0.9.0\n"
 "Report-Msgid-Bugs-To: <see README>\n"
-"POT-Creation-Date: 2013-03-10 17:21+0100\n"
+"POT-Creation-Date: 2016-02-17 21:25+0100\n"
 "PO-Revision-Date: 2011-02-15 21:11+0100\n"
 "Last-Translator: Milan Hrala <hrala.milan@gmail.com>\n"
 "Language-Team: Slovak <hrala.milan@gmail.com>\n"
@@ -70,6 +70,9 @@ msgstr "OSD zvyslé zarovnanie"
 msgid "Hide mainmenu entry"
 msgstr "Schovať položku v hlavnom menu"
 
+msgid "Text Font"
+msgstr ""
+
 msgid "Key bindings"
 msgstr "Klávesové skratky"
 
diff --git a/po/uk_UA.po b/po/uk_UA.po
index 6bd15dd..b1d35c1 100644
--- a/po/uk_UA.po
+++ b/po/uk_UA.po
@@ -7,7 +7,7 @@ msgid ""
 msgstr ""
 "Project-Id-Version: VDR 1.5.7\n"
 "Report-Msgid-Bugs-To: <see README>\n"
-"POT-Creation-Date: 2013-03-10 17:21+0100\n"
+"POT-Creation-Date: 2016-02-17 21:25+0100\n"
 "PO-Revision-Date: 2009-05-25 20:33+0200\n"
 "Last-Translator: Yarema P. aka Knedlyk <yupadmin@gmail.com>\n"
 "Language-Team: Ukrainian <vdr@linuxtv.org>\n"
@@ -70,6 +70,9 @@ msgstr "Вертикальне положення OSD"
 msgid "Hide mainmenu entry"
 msgstr ""
 
+msgid "Text Font"
+msgstr ""
+
 msgid "Key bindings"
 msgstr "Призначення клавіш"
 
diff --git a/setup.h b/setup.h
index a56809e..8856b48 100644
--- a/setup.h
+++ b/setup.h
@@ -46,6 +46,9 @@ public:
    int OSDVAlign;
    int inactivityTimeout;
    int HideMainMenu;
+   cString txtFontName;
+   cStringList txtFontNames;
+   int txtFontIndex;
 };
 
 extern TeletextSetup ttSetup;
diff --git a/txtfont.c b/txtfont.c
index 5cb9174..f89e397 100644
--- a/txtfont.c
+++ b/txtfont.c
@@ -52,7 +52,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000,  // ************ ****
   },
-  { // 0x23 = # = NC 
+  { // 0x23 = # = NC
    0x0000,  // ************ ****
    0x1980,  // ***##**##*** ****
    0x1980,  // ***##**##*** ****
@@ -88,7 +88,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0x26 = & 
+  { // 0x26 = &
    0x0000,  // ************ ****
    0x1E00,  // ***####***** ****
    0x3300,  // **##**##**** ****
@@ -1174,7 +1174,7 @@ unsigned int TXT_Font[][11]= {
    0x0000   // ************ ****
   },
 
-  { // 0x80 = 
+  { // 0x80 =
    0x0000,  // ************ ****
    0x1FC0,  // ***#######** ****
    0x3060,  // **##*****##* ****
@@ -1186,7 +1186,7 @@ unsigned int TXT_Font[][11]= {
    0x1FC0,  // ***#######** ****
    0x0000   // ************ ****
   },
-  { // 0x81 = 
+  { // 0x81 =
    0x0000,  // ************ ****
    0x0000,  // ************ ****
    0x0000,  // ************ ****
@@ -1198,7 +1198,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0x82 = 
+  { // 0x82 =
    0x0000,  // ************ ****
    0x3000,  // **##******** ****
    0x7000,  // *###******** ****
@@ -1210,7 +1210,7 @@ unsigned int TXT_Font[][11]= {
    0x07E0,  // *****######* ****
    0x0060   // *********##* ****
   },
-  { // 0x83 = 
+  { // 0x83 =
    0x0000,  // ************ ****
    0x0FC0,  // ****######** ****
    0x1860,  // ***##****##* ****
@@ -1270,7 +1270,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0x88 = 
+  { // 0x88 =
    0x0000,  // ************ ****
    0x3980,  // ***##**##*** ****
    0x3980,  // ***##**##*** ****
@@ -1282,7 +1282,7 @@ unsigned int TXT_Font[][11]= {
    0x3980,  // ***##**##*** ****
    0x0000   // ************ ****
   },
-  { // 0x89 = 
+  { // 0x89 =
    0x0000,  // ************ ****
    0x7C00,  // *#####****** ****
    0x0C00,  // ****##****** ****
@@ -1294,7 +1294,7 @@ unsigned int TXT_Font[][11]= {
    0x07E0,  // *****######* ****
    0x0060   // *********##* ****
   },
-  { // 0x8A = 
+  { // 0x8A =
    0x0000,  // ************ ****
    0x0000,  // ************ ****
    0x0600,  // *****##***** ****
@@ -1306,7 +1306,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0x8B = 
+  { // 0x8B =
    0x0000,  // ************ ****
    0x0000,  // ************ ****
    0x0600,  // *****##***** ****
@@ -1318,7 +1318,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0x8C = 
+  { // 0x8C =
    0x0000,  // ************ ****
    0x3000,  // **##******** ****
    0x7000,  // *###******** ****
@@ -1330,7 +1330,7 @@ unsigned int TXT_Font[][11]= {
    0x0300,  // ******##**** ****
    0x07E0   // *****######* ****
   },
-  { // 0x8D = 
+  { // 0x8D =
    0x0000,  // ************ ****
    0x0000,  // ************ ****
    0x0600,  // *****##***** ****
@@ -1342,7 +1342,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0x8E = 
+  { // 0x8E =
    0x0000,  // ************ ****
    0x0600,  // *****##***** ****
    0x0F00,  // ****####**** ****
@@ -1366,7 +1366,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0x90 = 
+  { // 0x90 =
    0x0300,  // ******##**** ****
    0x0600,  // *****##***** ****
    0x3FC0,  // **########** ****
@@ -1378,7 +1378,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0x91 = 
+  { // 0x91 =
    0x0300,  // ******##**** ****
    0x0600,  // *****##***** ****
    0x0000,  // ************ ****
@@ -1414,7 +1414,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
    },
-  { // 0x94 = 
+  { // 0x94 =
    0x0000,  // ************ ****
    0x6060,  // *##******##* ****
    0x30C0,  // **##****##** ****
@@ -1438,7 +1438,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0x96 = 
+  { // 0x96 =
    0xFFC0,  // ##########** ****
    0x0060,  // *********##* ****
    0x3E30,  // **#####***## ****
@@ -1450,7 +1450,7 @@ unsigned int TXT_Font[][11]= {
    0xFFC0,  // ##########** ****
    0x0000   // ************ ****
   },
-  { // 0x97 = 
+  { // 0x97 =
    0xFFC0,  // ##########** ****
    0x0860,  // ****#****##* ****
    0x1C30,  // ***###****## ****
@@ -1462,7 +1462,7 @@ unsigned int TXT_Font[][11]= {
    0xFFC0,  // ##########** ****
    0x0000   // ************ ****
   },
-  { // 0x98 = 
+  { // 0x98 =
    0x0000,  // ************ ****
    0x18C0,  // ***##***##** ****
    0x0000,  // ************ ****
@@ -1474,7 +1474,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0x99 = 
+  { // 0x99 =
    0x0E00,  // ****###***** ****
    0x1B00,  // ***##*##**** ****
    0x0E00,  // ****###***** ****
@@ -1486,7 +1486,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0x9A = 
+  { // 0x9A =
    0x0000,  // ************ ****
    0x18C0,  // ***##***##** ****
    0x0000,  // ************ ****
@@ -1498,7 +1498,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0x9B = 
+  { // 0x9B =
    0x18C0,  // ***##***##** ****
    0x0000,  // ************ ****
    0x1FC0,  // ***#######** ****
@@ -1510,7 +1510,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0x9C = 
+  { // 0x9C =
    0x18C0,  // ***##***##** ****
    0x0000,  // ************ ****
    0x1FC0,  // ***#######** ****
@@ -1522,7 +1522,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0x9D = 
+  { // 0x9D =
    0x0700,  // *****###**** ****
    0x0700,  // *****###**** ****
    0x1FC0,  // ***#######** ****
@@ -1534,7 +1534,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0x9E = 
+  { // 0x9E =
    0x18C0,  // ***##***##** ****
    0x0000,  // ************ ****
    0x3060,  // **##*****##* ****
@@ -1572,7 +1572,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xA1 = 0x21a 
+  { // 0xA1 = 0x21a
    0xFC00,  // ######****** ****
    0xFC00,  // ######****** ****
    0xFC00,  // ######****** ****
@@ -1596,7 +1596,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xA3 = 0x23a 
+  { // 0xA3 = 0x23a
    0xFFF0,  // ############ ****
    0xFFF0,  // ############ ****
    0xFFF0,  // ############ ****
@@ -1608,7 +1608,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xA4 = 0x24a 
+  { // 0xA4 = 0x24a
    0x0000,  // ************ ****
    0x0000,  // ************ ****
    0x0000,  // ************ ****
@@ -1620,7 +1620,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xA5 = 0x25a 
+  { // 0xA5 = 0x25a
    0xFC00,  // ######****** ****
    0xFC00,  // ######****** ****
    0xFC00,  // ######****** ****
@@ -1642,7 +1642,7 @@ unsigned int TXT_Font[][11]= {
    0xFC00,  // ######****** ****
    0x0000,  // ************ ****
    0x0000,  // ************ ****
-   0x0000   // ************ ****
+   0x0000   // ************ ****11
   },
   { // 0xA7 = 0x27a
    0xFFF0,  // ############ ****
@@ -1680,7 +1680,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xAA = 0x2Aa 
+  { // 0xAA = 0x2Aa
    0x03F0,  // ******###### ****
    0x03F0,  // ******###### ****
    0x03F0,  // ******###### ****
@@ -1728,7 +1728,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xAE = 0x2Ea 
+  { // 0xAE = 0x2Ea
    0x03F0,  // ******###### ****
    0x03F0,  // ******###### ****
    0x03F0,  // ******###### ****
@@ -1740,7 +1740,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xAF = 0x2Fa 
+  { // 0xAF = 0x2Fa
    0xFFF0,  // ############ ****
    0xFFF0,  // ############ ****
    0xFFF0,  // ############ ****
@@ -1777,7 +1777,7 @@ unsigned int TXT_Font[][11]= {
    0xFC00,  // ######****** ****
    0xFC00   // ######****** ****
   },
-  { // 0xB2 = 0x32a 
+  { // 0xB2 = 0x32a
    0x03F0,  // ******###### ****
    0x03F0,  // ******###### ****
    0x03F0,  // ******###### ****
@@ -1789,7 +1789,7 @@ unsigned int TXT_Font[][11]= {
    0xFC00,  // ######****** ****
    0xFC00   // ######****** ****
   },
-  { // 0xB3 = 0x33a 
+  { // 0xB3 = 0x33a
    0xFFF0,  // ############ ****
    0xFFF0,  // ############ ****
    0xFFF0,  // ############ ****
@@ -1801,7 +1801,7 @@ unsigned int TXT_Font[][11]= {
    0xFC00,  // ######****** ****
    0xFC00   // ######****** ****
   },
-  { // 0xB4 = 0x34a 
+  { // 0xB4 = 0x34a
    0x0000,  // ************ ****
    0x0000,  // ************ ****
    0x0000,  // ************ ****
@@ -1825,7 +1825,7 @@ unsigned int TXT_Font[][11]= {
    0xFC00,  // ######****** ****
    0xFC00   // ######****** ****
   },
-  { // 0xB6 = 0x36a 
+  { // 0xB6 = 0x36a
    0x03F0,  // ******###### ****
    0x03F0,  // ******###### ****
    0x03F0,  // ******###### ****
@@ -1837,7 +1837,7 @@ unsigned int TXT_Font[][11]= {
    0xFC00,  // ######****** ****
    0xFC00   // ######****** ****
   },
-  { // 0xB7 = 0x37a 
+  { // 0xB7 = 0x37a
    0xFFF0,  // ############ ****
    0xFFF0,  // ############ ****
    0xFFF0,  // ############ ****
@@ -1849,7 +1849,7 @@ unsigned int TXT_Font[][11]= {
    0xFC00,  // ######****** ****
    0xFC00   // ######****** ****
   },
-  { // 0xB8 = 0x38a 
+  { // 0xB8 = 0x38a
    0x0000,  // ************ ****
    0x0000,  // ************ ****
    0x0000,  // ************ ****
@@ -1861,7 +1861,7 @@ unsigned int TXT_Font[][11]= {
    0xFC00,  // ######****** ****
    0xFC00   // ######****** ****
   },
-  { // 0xB9 = 0x39a 
+  { // 0xB9 = 0x39a
    0xFC00,  // ######****** ****
    0xFC00,  // ######****** ****
    0xFC00,  // ######****** ****
@@ -1873,7 +1873,7 @@ unsigned int TXT_Font[][11]= {
    0xFC00,  // ######****** ****
    0xFC00   // ######****** ****
   },
-  { // 0xBA = 0x3Aa 
+  { // 0xBA = 0x3Aa
    0x03F0,  // ******###### ****
    0x03F0,  // ******###### ****
    0x03F0,  // ******###### ****
@@ -1885,7 +1885,7 @@ unsigned int TXT_Font[][11]= {
    0xFC00,  // ######****** ****
    0xFC00   // ######****** ****
   },
-  { // 0xBB = 0x3Ba 
+  { // 0xBB = 0x3Ba
    0xFFF0,  // ############ ****
    0xFFF0,  // ############ ****
    0xFFF0,  // ############ ****
@@ -1897,7 +1897,7 @@ unsigned int TXT_Font[][11]= {
    0xFC00,  // ######****** ****
    0xFC00   // ######****** ****
   },
-  { // 0xBC = 0x3Ca 
+  { // 0xBC = 0x3Ca
    0x0000,  // ************ ****
    0x0000,  // ************ ****
    0x0000,  // ************ ****
@@ -1909,7 +1909,7 @@ unsigned int TXT_Font[][11]= {
    0xFC00,  // ######****** ****
    0xFC00   // ######****** ****
   },
-  { // 0xBD = 0x3Da 
+  { // 0xBD = 0x3Da
    0xFC00,  // ######****** ****
    0xFC00,  // ######****** ****
    0xFC00,  // ######****** ****
@@ -1921,7 +1921,7 @@ unsigned int TXT_Font[][11]= {
    0xFC00,  // ######****** ****
    0xFC00   // ######****** ****
   },
-  { // 0xBE = 0x3Ea 
+  { // 0xBE = 0x3Ea
    0x03F0,  // ******###### ****
    0x03F0,  // ******###### ****
    0x03F0,  // ******###### ****
@@ -1933,7 +1933,7 @@ unsigned int TXT_Font[][11]= {
    0xFC00,  // ######****** ****
    0xFC00   // ######****** ****
   },
-  { // 0xBF = 0x3Fa 
+  { // 0xBF = 0x3Fa
    0xFFFF,  // ############ ****
    0xFFFF,  // ############ ****
    0xFFFF,  // ############ ****
@@ -1946,7 +1946,7 @@ unsigned int TXT_Font[][11]= {
    0xFC00   // ######****** ****
   },
 
-  { // 0xC0 = 
+  { // 0xC0 =
    0x0600,  // *****##***** ****
    0x0C00,  // ****##****** ****
    0x0000,  // ************ ****
@@ -1958,7 +1958,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xC1 = 
+  { // 0xC1 =
    0x0600,  // *****##***** ****
    0x0300,  // ******##**** ****
    0x0000,  // ************ ****
@@ -1970,7 +1970,7 @@ unsigned int TXT_Font[][11]= {
    0x1F60,  // ***#####*##* ****
    0x0000   // ************ ****
   },
-  { // 0xC2 = 
+  { // 0xC2 =
    0x0C00,  // ****##****** ****
    0x0600,  // *****##***** ****
    0x0000,  // ************ ****
@@ -1982,7 +1982,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xC3 = 
+  { // 0xC3 =
    0x0000,  // ************ ****
    0x0FC0,  // ****######** ****
    0x1860,  // ***##****##* ****
@@ -1994,7 +1994,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xC4 = 
+  { // 0xC4 =
    0x0600,  // *****##***** ****
    0x3FC0,  // **########** ****
    0x6660,  // *##**##**##* ****
@@ -2006,7 +2006,7 @@ unsigned int TXT_Font[][11]= {
    0x06C0,  // *****##***** ****
    0x0000   // ************ ****
   },
-  { // 0xC5 = 
+  { // 0xC5 =
    0x3CC0,  // **####**##** ****
    0x6780,  // *##**####*** ****
    0x0000,  // ************ ****
@@ -2018,7 +2018,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xC6 = 
+  { // 0xC6 =
    0x3C60,  // **####***##* ****
    0x67C0,  // *##**#####** ****
    0x0000,  // ************ ****
@@ -2030,7 +2030,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xC7 = 
+  { // 0xC7 =
    0x0000,  // ************ ****
    0x0000,  // ************ ****
    0x0000,  // ************ ****
@@ -2042,7 +2042,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xC8 = 
+  { // 0xC8 =
    0x0600,  // *****##***** ****
    0x0300,  // ******##**** ****
    0x0000,  // ************ ****
@@ -2054,7 +2054,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xC9 = 
+  { // 0xC9 =
    0x0600,  // *****##***** ****
    0x0300,  // ******##**** ****
    0x0000,  // ************ ****
@@ -2066,7 +2066,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xCA = 
+  { // 0xCA =
    0x0C00,  // ****##****** ****
    0x0600,  // *****##***** ****
    0x0000,  // ************ ****
@@ -2078,7 +2078,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xCB = 
+  { // 0xCB =
    0x0000,  // ************ ****
    0x0780,  // *****####*** ****
    0x0CC0,  // ****##**##** ****
@@ -2090,7 +2090,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xCC = 
+  { // 0xCC =
    0x0000,  // ************ ****
    0x0000,  // ************ ****
    0x0000,  // ************ ****
@@ -2102,7 +2102,7 @@ unsigned int TXT_Font[][11]= {
    0x0300,  // ******##**** ****
    0x0E00   // ****###***** ****
   },
-  { // 0xCD = 
+  { // 0xCD =
    0x0000,  // ************ ****
    0x0000,  // ************ ****
    0x0600,  // *****##***** ****
@@ -2114,7 +2114,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xCE = 
+  { // 0xCE =
    0x0000,  // ************ ****
    0x0600,  // *****##***** ****
    0x0F00,  // ****####**** ****
@@ -2126,7 +2126,7 @@ unsigned int TXT_Font[][11]= {
    0x0600,  // *****##***** ****
    0x0600   // *****##***** ****
   },
-  { // 0xCF = 
+  { // 0xCF =
    0x0000,  // ************ ****
    0x1980,  // ***##**##*** ****
    0x1980,  // ***##**##*** ****
@@ -2139,7 +2139,7 @@ unsigned int TXT_Font[][11]= {
    0x0000   // ************ ****
   },
 
-  { // 0xD0 = 
+  { // 0xD0 =
    0x0C00,  // ****##****** ****
    0x0600,  // *****##***** ****
    0x0000,  // ************ ****
@@ -2151,7 +2151,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xD1 = 
+  { // 0xD1 =
    0x0600,  // *****##***** ****
    0x0300,  // ******##**** ****
    0x0000,  // ************ ****
@@ -2163,7 +2163,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xD2 = 
+  { // 0xD2 =
    0x0E00,  // ****###***** ****
    0x1B00,  // ***##*##**** ****
    0x0000,  // ************ ****
@@ -2175,7 +2175,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xD3 = 
+  { // 0xD3 =
    0x0300,  // ******##**** ****
    0x0600,  // *****##***** ****
    0x0000,  // ************ ****
@@ -2187,7 +2187,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xD4 = 
+  { // 0xD4 =
    0x0000,  // ************ ****
    0x1980,  // ***##**##*** ****
    0x0000,  // ************ ****
@@ -2199,7 +2199,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xD5 = 
+  { // 0xD5 =
    0x1E60,  // ***####**##* ****
    0x33C0,  // **##**####** ****
    0x1F80,  // ***######*** ****
@@ -2211,7 +2211,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xD6 = 
+  { // 0xD6 =
    0x1E60,  // ***####**##* ****
    0x33C0,  // **##**####** ****
    0x1FC0,  // ***#######** ****
@@ -2223,7 +2223,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xD7 = 
+  { // 0xD7 =
    0x0000,  // ************ ****
    0x0FC0,  // ****######** ****
    0x1860,  // ***##****##* ****
@@ -2235,7 +2235,7 @@ unsigned int TXT_Font[][11]= {
    0x0300,  // ******##**** ****
    0x0E00   // ****###***** ****
   },
-  { // 0xD8 = 
+  { // 0xD8 =
    0x0700,  // *****###**** ****
    0x0D80,  // ****##*##*** ****
    0x0000,  // ************ ****
@@ -2247,7 +2247,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xD9 = 
+  { // 0xD9 =
    0x0700,  // *****###**** ****
    0x0D80,  // ****##*##*** ****
    0x0000,  // ************ ****
@@ -2259,7 +2259,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xDA = 
+  { // 0xDA =
    0x0000,  // ************ ****
    0x0000,  // ************ ****
    0x0000,  // ************ ****
@@ -2271,7 +2271,7 @@ unsigned int TXT_Font[][11]= {
    0x0300,  // ******##**** ****
    0x0E00   // ****###***** ****
   },
-  { // 0xDB = 
+  { // 0xDB =
    0x0000,  // ************ ****
    0x18C0,  // ***##***##** ****
    0x0000,  // ************ ****
@@ -2283,7 +2283,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xDC = 
+  { // 0xDC =
    0x0700,  // *****###**** ****
    0x0D80,  // ****##*##*** ****
    0x0000,  // ************ ****
@@ -2295,7 +2295,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xDD = 
+  { // 0xDD =
    0x0600,  // *****##***** ****
    0x0300,  // ******##**** ****
    0x0000,  // ************ ****
@@ -2307,7 +2307,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xDE = 
+  { // 0xDE =
    0x0F00,  // ****####**** ****
    0x1980,  // ***##**##*** ****
    0x0000,  // ************ ****
@@ -2319,7 +2319,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xDF = 
+  { // 0xDF =
    0x0000,  // ************ ****
    0x1980,  // ***##**##*** ****
    0x1980,  // ***##**##*** ****
@@ -2332,7 +2332,7 @@ unsigned int TXT_Font[][11]= {
    0x0000   // ************ ****
   },
 
-  { // 0xE0 = 
+  { // 0xE0 =
    0x0000,  // ************ ****
    0x0600,  // *****##***** ****
    0x0000,  // ************ ****
@@ -2344,7 +2344,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xE1 = 
+  { // 0xE1 =
    0x0000,  // ************ ****
    0x0600,  // *****##***** ****
    0x0000,  // ************ ****
@@ -2356,7 +2356,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xE2 = 
+  { // 0xE2 =
    0x0000,  // ************ ****
    0x18C0,  // ***##***##** ****
    0x0000,  // ************ ****
@@ -2368,7 +2368,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xE3 = 
+  { // 0xE3 =
    0x0000,  // ************ ****
    0x0000,  // ************ ****
    0x0000,  // ************ ****
@@ -2380,7 +2380,7 @@ unsigned int TXT_Font[][11]= {
    0x0300,  // ******##**** ****
    0x0E00   // ****###***** ****
   },
-  { // 0xE4 = 
+  { // 0xE4 =
    0x0600,  // *****##***** ****
    0x3FC0,  // **########** ****
    0x6660,  // *##**##**##* ****
@@ -2392,7 +2392,7 @@ unsigned int TXT_Font[][11]= {
    0x0600,  // *****##***** ****
    0x0000   // ************ ****
   },
-  { // 0xE5 = 
+  { // 0xE5 =
    0x0000,  // ************ ****
    0x3F80,  // **#######*** ****
    0x6180,  // *##****##*** ****
@@ -2404,7 +2404,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xE6 = 
+  { // 0xE6 =
    0x0000,  // ************ ****
    0x1FC0,  // ***#######** ****
    0x3060,  // **##*****##* ****
@@ -2416,7 +2416,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xE7 = 
+  { // 0xE7 =
    0x1E60,  // ***####**##* ****
    0x33C0,  // **##**####** ****
    0x3860,  // **###****##* ****
@@ -2428,7 +2428,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xE8 = 
+  { // 0xE8 =
    0x1E60,  // ***####**##* ****
    0x33C0,  // **##**####** ****
    0x0000,  // ************ ****
@@ -2440,7 +2440,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xE9 = 
+  { // 0xE9 =
    0x0600,  // *****##***** ****
    0x0300,  // ******##**** ****
    0x0000,  // ************ ****
@@ -2452,7 +2452,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xEA = 
+  { // 0xEA =
    0x0C00,  // ****##****** ****
    0x0600,  // *****##***** ****
    0x0000,  // ************ ****
@@ -2464,7 +2464,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xEB = 
+  { // 0xEB =
    0x0300,  // ******##**** ****
    0x0600,  // *****##***** ****
    0x0000,  // ************ ****
@@ -2476,7 +2476,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xEC = 
+  { // 0xEC =
    0x0300,  // ******##**** ****
    0x0600,  // *****##***** ****
    0x0000,  // ************ ****
@@ -2488,7 +2488,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xED = 
+  { // 0xED =
    0x0300,  // ******##**** ****
    0x0600,  // *****##***** ****
    0x0000,  // ************ ****
@@ -2500,7 +2500,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xEE = 
+  { // 0xEE =
    0x0300,  // ******##**** ****
    0x0600,  // *****##***** ****
    0x0000,  // ************ ****
@@ -2512,7 +2512,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xEF = 
+  { // 0xEF =
    0x0300,  // ******##**** ****
    0x0600,  // *****##***** ****
    0x0000,  // ************ ****
@@ -2525,7 +2525,7 @@ unsigned int TXT_Font[][11]= {
    0x0000   // ************ ****
   },
 
-  { // 0xF0 = 
+  { // 0xF0 =
    0x0300,  // ******##**** ****
    0x0600,  // *****##***** ****
    0x1FC0,  // ***#######** ****
@@ -2537,7 +2537,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xF1 = 
+  { // 0xF1 =
    0x0C00,  // ****##****** ****
    0x0600,  // *****##***** ****
    0x1FC0,  // ***#######** ****
@@ -2549,7 +2549,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xF2 = 
+  { // 0xF2 =
    0x0C00,  // ****##****** ****
    0x0600,  // *****##***** ****
    0x3FC0,  // **########** ****
@@ -2561,7 +2561,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xF3 = 
+  { // 0xF3 =
    0x0300,  // ******##**** ****
    0x0600,  // *****##***** ****
    0x3FC0,  // **########** ****
@@ -2573,7 +2573,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xF4 = 
+  { // 0xF4 =
    0x19C0,  // ***##**##*** ****
    0x0000,  // ************ ****
    0x3FC0,  // **########** ****
@@ -2585,7 +2585,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xF5 = 
+  { // 0xF5 =
    0x0300,  // ******##**** ****
    0x0600,  // *****##***** ****
    0x1FC0,  // ***#######** ****
@@ -2597,7 +2597,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xF6 = 
+  { // 0xF6 =
    0x0600,  // *****##***** ****
    0x0300,  // ******##**** ****
    0x1FC0,  // ***#######** ****
@@ -2609,7 +2609,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xF7 = 
+  { // 0xF7 =
    0x0300,  // ******##**** ****
    0x0600,  // *****##***** ****
    0x3060,  // **##*****##* ****
@@ -2621,7 +2621,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xF8 = 
+  { // 0xF8 =
    0x0000,  // ************ ****
    0x0000,  // ************ ****
    0x0000,  // ************ ****
@@ -2633,7 +2633,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xF9 = 
+  { // 0xF9 =
    0x0000,  // ************ ****
    0x0FE0,  // ****#######* ****
    0x1B00,  // ***##*##**** ****
@@ -2645,7 +2645,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xFA = 
+  { // 0xFA =
    0x0000,  // ************ ****
    0x0300,  // ******##**** ****
    0x0FC0,  // ****######** ****
@@ -2657,7 +2657,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xFB = 
+  { // 0xFB =
    0x0000,  // ************ ****
    0x3F80,  // **#######*** ****
    0x30C0,  // **##****##** ****
@@ -2669,7 +2669,7 @@ unsigned int TXT_Font[][11]= {
    0x0000,  // ************ ****
    0x0000   // ************ ****
   },
-  { // 0xFC = 
+  { // 0xFC =
    0x0000,  // ************ ****
    0x0000,  // ************ ****
    0x0180,  // *******##*** ****
@@ -2681,7 +2681,7 @@ unsigned int TXT_Font[][11]= {
    0x1800,  // ***##******* ****
    0x0000   // ************ ****
   },
-  { // 0xFD = 
+  { // 0xFD =
    0x0060,  // *********##* ****
    0x3FC0,  // **########** ****
    0x61E0,  // *##****####* ****
@@ -2693,7 +2693,7 @@ unsigned int TXT_Font[][11]= {
    0x6000,  // *##********* ****
    0x0000   // ************ ****
   },
-  { // 0xFE = 
+  { // 0xFE =
    0x0000,  // ************ ****
    0x3000,  // **##******** ****
    0x3000,  // **##******** ****
@@ -2705,7 +2705,7 @@ unsigned int TXT_Font[][11]= {
    0x3000,  // **##******** ****
    0x3000   // **##******** ****
   },
-  { // 0xFF = 
+  { // 0xFF =
    0x3C00,  // **####****** ****
    0x1800,  // ***##******* ****
    0x1F80,  // ***######*** ****
@@ -2718,7 +2718,7 @@ unsigned int TXT_Font[][11]= {
    0x0000   // ************ ****
   },
 
-  { // 0x60a = 
+  { // 0x60a =
    0x0000,  // ************ ****
    0x0000,  // ************ ****
    0x0000,  // ************ ****
@@ -2730,7 +2730,7 @@ unsigned int TXT_Font[][11]= {
    0x03F0,  // ******###### ****
    0x03F0   // ******###### ****
   },
-  { // 0x61a = 
+  { // 0x61a =
    0xFC00,  // ######****** ****
    0xFC00,  // ######****** ****
    0xFC00,  // ######****** ****
@@ -2742,7 +2742,7 @@ unsigned int TXT_Font[][11]= {
    0x03F0,  // ******###### ****
    0x03F0   // ******###### ****
   },
-  { // 0x62a = 
+  { // 0x62a =
    0x03F0,  // ******###### ****
    0x03F0,  // ******###### ****
    0x03F0,  // ******###### ****
@@ -2754,7 +2754,7 @@ unsigned int TXT_Font[][11]= {
    0x03F0,  // ******###### ****
    0x03F0   // ******###### ****
   },
-  { // 0x63a = 
+  { // 0x63a =
    0xFFF0,  // ############ ****
    0xFFF0,  // ############ ****
    0xFFF0,  // ############ ****
@@ -2766,7 +2766,7 @@ unsigned int TXT_Font[][11]= {
    0x03F0,  // ******###### ****
    0x03F0   // ******###### ****
   },
-  { // 0x64a = 
+  { // 0x64a =
    0x0000,  // ************ ****
    0x0000,  // ************ ****
    0x0000,  // ************ ****
@@ -2778,7 +2778,7 @@ unsigned int TXT_Font[][11]= {
    0x03F0,  // ******###### ****
    0x03F0   // ******###### ****
   },
-  { // 0x65a = 
+  { // 0x65a =
    0xFC00,  // ######****** ****
    0xFC00,  // ######****** ****
    0xFC00,  // ######****** ****
@@ -2790,7 +2790,7 @@ unsigned int TXT_Font[][11]= {
    0x03F0,  // ******###### ****
    0x03F0   // ******###### ****
   },
-  { // 0x66a = 
+  { // 0x66a =
    0x03F0,  // ******###### ****
    0x03F0,  // ******###### ****
    0x03F0,  // ******###### ****
@@ -2802,7 +2802,7 @@ unsigned int TXT_Font[][11]= {
    0x03F0,  // ******###### ****
    0x03F0   // ******###### ****
   },
-  { // 0x67a = 
+  { // 0x67a =
    0xFFF0,  // ############ ****
    0xFFF0,  // ############ ****
    0xFFF0,  // ############ ****
@@ -2814,7 +2814,7 @@ unsigned int TXT_Font[][11]= {
    0x03F0,  // ******###### ****
    0x03F0   // ******###### ****
   },
-  { // 0x68a = 
+  { // 0x68a =
    0x0000,  // ************ ****
    0x0000,  // ************ ****
    0x0000,  // ************ ****
@@ -2826,7 +2826,7 @@ unsigned int TXT_Font[][11]= {
    0x03F0,  // ******###### ****
    0x03F0   // ******###### ****
   },
-  { // 0x69a = 
+  { // 0x69a =
    0xFC00,  // ######****** ****
    0xFC00,  // ######****** ****
    0xFC00,  // ######****** ****
@@ -2838,7 +2838,7 @@ unsigned int TXT_Font[][11]= {
    0x03F0,  // ******###### ****
    0x03F0   // ******###### ****
   },
-  { // 0x6Aa = 
+  { // 0x6Aa =
    0x03F0,  // ******###### ****
    0x03F0,  // ******###### ****
    0x03F0,  // ******###### ****
@@ -2850,7 +2850,7 @@ unsigned int TXT_Font[][11]= {
    0x03F0,  // ******###### ****
    0x03F0   // ******###### ****
   },
-  { // 0x6Ba = 
+  { // 0x6Ba =
    0xFFF0,  // ############ ****
    0xFFF0,  // ############ ****
    0xFFF0,  // ############ ****
@@ -2862,7 +2862,7 @@ unsigned int TXT_Font[][11]= {
    0x03F0,  // ******###### ****
    0x03F0   // ******###### ****
   },
-  { // 0x6Ca = 
+  { // 0x6Ca =
    0x0000,  // ************ ****
    0x0000,  // ************ ****
    0x0000,  // ************ ****
@@ -2874,7 +2874,7 @@ unsigned int TXT_Font[][11]= {
    0x03F0,  // ******###### ****
    0x03F0   // ******###### ****
   },
-  { // 0x6Da = 
+  { // 0x6Da =
    0xFC00,  // ######****** ****
    0xFC00,  // ######****** ****
    0xFC00,  // ######****** ****
@@ -2886,7 +2886,7 @@ unsigned int TXT_Font[][11]= {
    0x03F0,  // ******###### ****
    0x03F0   // ******###### ****
   },
-  { // 0x6Ea = 
+  { // 0x6Ea =
    0x03F0,  // ******###### ****
    0x03F0,  // ******###### ****
    0x03F0,  // ******###### ****
@@ -2898,7 +2898,7 @@ unsigned int TXT_Font[][11]= {
    0x03F0,  // ******###### ****
    0x03F0   // ******###### ****
   },
-  { // 0x6Fa = 
+  { // 0x6Fa =
    0xFFF0,  // ############ ****
    0xFFF0,  // ############ ****
    0xFFF0,  // ############ ****
@@ -2911,7 +2911,7 @@ unsigned int TXT_Font[][11]= {
    0x03F0   // ******###### ****
   },
 
-  { // 0x70a = 
+  { // 0x70a =
    0x0000,  // ************ ****
    0x0000,  // ************ ****
    0x0000,  // ************ ****
@@ -2923,7 +2923,7 @@ unsigned int TXT_Font[][11]= {
    0xFFF0,  // ############ ****
    0xFFF0   // ############ ****
   },
-  { // 0x71a = 
+  { // 0x71a =
    0xFC00,  // ######****** ****
    0xFC00,  // ######****** ****
    0xFC00,  // ######****** ****
@@ -2935,7 +2935,7 @@ unsigned int TXT_Font[][11]= {
    0xFFF0,  // ############ ****
    0xFFF0   // ############ ****
   },
-  { // 0x72a = 
+  { // 0x72a =
    0x03F0,  // ******###### ****
    0x03F0,  // ******###### ****
    0x03F0,  // ******###### ****
@@ -2947,7 +2947,7 @@ unsigned int TXT_Font[][11]= {
    0xFFF0,  // ############ ****
    0xFFF0   // ############ ****
   },
-  { // 0x73a = 
+  { // 0x73a =
    0xFFF0,  // ############ ****
    0xFFF0,  // ############ ****
    0xFFF0,  // ############ ****
@@ -2959,7 +2959,7 @@ unsigned int TXT_Font[][11]= {
    0xFFF0,  // ############ ****
    0xFFF0   // ############ ****
   },
-  { // 0x74a = 
+  { // 0x74a =
    0x0000,  // ************ ****
    0x0000,  // ************ ****
    0x0000,  // ************ ****
@@ -2971,7 +2971,7 @@ unsigned int TXT_Font[][11]= {
    0xFFF0,  // ############ ****
    0xFFF0   // ############ ****
   },
-  { // 0x75a = 
+  { // 0x75a =
    0xFC00,  // ######****** ****
    0xFC00,  // ######****** ****
    0xFC00,  // ######****** ****
@@ -2983,7 +2983,7 @@ unsigned int TXT_Font[][11]= {
    0xFFF0,  // ############ ****
    0xFFF0   // ############ ****
   },
-  { // 0x76a = 
+  { // 0x76a =
    0x03F0,  // ******###### ****
    0x03F0,  // ******###### ****
    0x03F0,  // ******###### ****
@@ -2995,7 +2995,7 @@ unsigned int TXT_Font[][11]= {
    0xFFF0,  // ############ ****
    0xFFF0   // ############ ****
   },
-  { // 0x77a = 
+  { // 0x77a =
    0xFFF0,  // ############ ****
    0xFFF0,  // ############ ****
    0xFFF0,  // ############ ****
@@ -3007,7 +3007,7 @@ unsigned int TXT_Font[][11]= {
    0xFFF0,  // ############ ****
    0xFFF0   // ############ ****
   },
-  { // 0x78a = 
+  { // 0x78a =
    0x0000,  // ************ ****
    0x0000,  // ************ ****
    0x0000,  // ************ ****
@@ -3019,7 +3019,7 @@ unsigned int TXT_Font[][11]= {
    0xFFF0,  // ############ ****
    0xFFF0   // ############ ****
   },
-  { // 0x79a = 
+  { // 0x79a =
    0xFC00,  // ######****** ****
    0xFC00,  // ######****** ****
    0xFC00,  // ######****** ****
@@ -3031,7 +3031,7 @@ unsigned int TXT_Font[][11]= {
    0xFFF0,  // ############ ****
    0xFFF0   // ############ ****
   },
-  { // 0x7Aa = 
+  { // 0x7Aa =
    0x03F0,  // ******###### ****
    0x03F0,  // ******###### ****
    0x03F0,  // ******###### ****
@@ -3043,7 +3043,7 @@ unsigned int TXT_Font[][11]= {
    0xFFF0,  // ############ ****
    0xFFF0   // ############ ****
   },
-  { // 0x7Ba = 
+  { // 0x7Ba =
    0xFFF0,  // ############ ****
    0xFFF0,  // ############ ****
    0xFFF0,  // ############ ****
@@ -3055,7 +3055,7 @@ unsigned int TXT_Font[][11]= {
    0xFFF0,  // ############ ****
    0xFFF0   // ############ ****
   },
-  { // 0x7Ca = 
+  { // 0x7Ca =
    0x0000,  // ************ ****
    0x0000,  // ************ ****
    0x0000,  // ************ ****
@@ -3067,7 +3067,7 @@ unsigned int TXT_Font[][11]= {
    0xFFF0,  // ############ ****
    0xFFF0   // ############ ****
   },
-  { // 0x7Da = 
+  { // 0x7Da =
    0xFC00,  // ######****** ****
    0xFC00,  // ######****** ****
    0xFC00,  // ######****** ****
@@ -3079,7 +3079,7 @@ unsigned int TXT_Font[][11]= {
    0xFFF0,  // ############ ****
    0xFFF0   // ############ ****
   },
-  { // 0x7Ea = 
+  { // 0x7Ea =
    0x03F0,  // ******###### ****
    0x03F0,  // ******###### ****
    0x03F0,  // ******###### ****
@@ -3091,7 +3091,7 @@ unsigned int TXT_Font[][11]= {
    0xFFF0,  // ############ ****
    0xFFF0   // ############ ****
   },
-  { // 0x7Fa = 
+  { // 0x7Fa =
    0xFFF0,  // ############ ****
    0xFFF0,  // ############ ****
    0xFFF0,  // ############ ****
@@ -3104,9 +3104,9 @@ unsigned int TXT_Font[][11]= {
    0xFFF0,  // ############ ****
   }
 };
-   
 
 
+#if 0
 int NationalOptionSubsetG0Default[13]=
     {0x23,0x94,0x80,0   ,0   ,0   ,0x5e,0x5f,0   ,0   ,0   ,0   ,0   };
 
@@ -3136,7 +3136,50 @@ int NationalOptionSubsetSV_FI[13]=
     {0x23,0x94,0x90,0x5b,0x5c,0x9d,0x5d,0x5f,0x91,0x7b,0x7c,0x99,0x7d};
 int NationalOptionSubsetTR[13]=
     {0   ,0   ,0   ,0   ,0x5c,0xd7,0x5d,0   ,0   ,0   ,0x7c,0xcc,0x7d};
-
+#else
+int NationalOptionSubsetG0Default[13]=
+    {    '#', 0x00A4,    '@',    '[',   '\\',    ']',    '^',    '_',    '`',    '{',    '|',    '}',    '~' }; /* 0          */
+//    { 0x0023, 0xc2a4, 0x0040, 0x0000, 0x0000, 0x0000, 0x005e, 0x005f, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000};
+int NationalOptionSubsetCZ_SK[13]=
+    {    '#', 0x016F, 0x010D, 0x0165, 0x017E, 0x00FD, 0x00ED, 0x0159, 0x00E9, 0x00E1, 0x011B, 0x00FA, 0x0161 }; /* 1  CS/SK   */
+//    { 0x0023, 0x0084, 0x0085, 0x0095, 0x0093, 0x0092, 0x00ed, 0x0087, 0x0091, 0x00eb, 0x008f, 0x00ef, 0x0086};
+int NationalOptionSubsetEN[13]=
+    { 0x00A3,    '$',    '@', 0x2190, 0x00BD, 0x2192, 0x2191,    '#', 0x00AD, 0x00BC, 0x2551, 0x00BE, 0x00F7 }; /* 2    EN    */
+//    { 0x0083, 0x0024, 0x0080, 0x008b, 0x008c, 0x008d, 0x008e, 0x0023, 0x0081, 0x0082, 0x0088, 0x0089, 0x008a};
+int NationalOptionSubsetEE[13]=
+    {    '#', 0x00F5, 0x0161, 0x00C4, 0x00D6, 0x017D, 0x00DC, 0x00D5, 0x0161, 0x00E4, 0x00F6, 0x017E, 0x00FC }; /* 3    ET    */
+//    { 0x0023, 0x00c6, 0x0000, 0x005b, 0x005c, 0x0000, 0x005d, 0x00d6, 0x0000, 0x007b, 0x007c, 0x0000, 0x007d};
+int NationalOptionSubsetFR[13]=
+    { 0x00E9, 0x0457, 0x00E0, 0x0451, 0x00EA, 0x00F9, 0x00EE,    '#', 0x00E8, 0x00E2, 0x00F4, 0x00FB, 0x00E7 }; /* 4    FR    */
+//    { 0x00d3, 0x00d4, 0x00d0, 0x00db, 0x00dc, 0x00c1, 0x00de, 0x0023, 0x00d1, 0x00d2, 0x00d8, 0x00d9, 0x00cc};
+int NationalOptionSubsetDE[13]=
+    { '#',       '$', 0x00A7, 0x00C4, 0x00D6, 0x00DC,    '^',    '_', 0x00B0, 0x00E4, 0x00F6, 0x00FC, 0x00DF }; /* 5    DE    */
+//    { 0x0023, 0x0024, 0xc2a7, 0xc384, 0xc396, 0xc39c, 0x005e, 0x005f, 0x0060, 0xc3a4, 0xc3b6, 0xc3bc, 0xc39f};
+int NationalOptionSubsetIT[13]=
+    { 0x00A3,    '$', 0x00E9, 0x00B0, 0x00E7, 0x2192, 0x2191,    '#', 0x00F9, 0x00E0, 0x00F3, 0x00E8, 0x00EC }; /* 6    IT    */
+//    { 0x0083, 0x0024, 0x00d3, 0x0060, 0x00cc, 0x008d, 0x008e, 0x0023, 0x00dd, 0x00c1, 0x00c8, 0x00c9, 0x00ca};
+int NationalOptionSubsetLV_LT[13]=
+    { '#',       '$', 0x0161, 0x0117, 0x0119, 0x017D, 0x010D, 0x016B, 0x0161, 0x0105, 0x0173, 0x017E, 0x012F }; /* 7  LV/LT   */
+//    { 0x0023, 0x0024, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000};
+int NationalOptionSubsetPL[13]=
+    { '#',    0x0144, 0x0105, 0x017B, 0x015A, 0x0141, 0x0107, 0x00F3, 0x0119, 0x017C, 0x015B, 0x0142, 0x017A }; /* 8    PL    */
+//    { 0x0023, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x00ee, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000};
+int NationalOptionSubsetPT_ES[13]=
+    { 0x00E7,    '$', 0x00A1, 0x00E1, 0x00E9, 0x00ED, 0x00F3, 0x00FA, 0x00BF, 0x00FC, 0x00F1, 0x00E8, 0x00E0 }; /* 9  PT/ES   */
+//    { 0x00cc, 0x0024, 0x00e0, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef, 0x00e1, 0x007d, 0x00e8, 0x00c9, 0x00c2};
+int NationalOptionSubsetRO[13]=
+    { '#',    0x00A4, 0x0162, 0x00C2, 0x015E, 0x01CD, 0x01CF, 0x0131, 0x0163, 0x00E2, 0x015F, 0x01CE, 0x00EE }; /* A    RO    */
+//    { 0x0023, 0x0094, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x00d2, 0x0000, 0x0000, 0x00de};
+int NationalOptionSubsetSR_HR_SL[13]=
+    { '#',    0x00CB, 0x010C, 0x0106, 0x017D, 0x00D0, 0x0160, 0x0451, 0x010D, 0x0107, 0x017E, 0x0111, 0x0161 }; /* B SR/HR/SL */
+//    { 0x0023, 0x0000, 0x0000, 0x0000, 0x0000, 0x00fb, 0x0000, 0x00db, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000};
+int NationalOptionSubsetSV_FI[13]=
+    { '#',    0x00A4, 0x00C9, 0x00C4, 0x00D6, 0x00C5, 0x00DC,    '_', 0x00E9, 0x00E4, 0x00F6, 0x00E5, 0x00FC }; /* C SV/FI/HU */
+//    { 0x0023, 0x0094, 0x0090, 0x005b, 0x005c, 0x009d, 0x005d, 0x005f, 0x0091, 0x007b, 0x007c, 0x0099, 0x007d};
+int NationalOptionSubsetTR[13]=
+    { 0x20A4, 0x011F, 0x0130, 0x015E, 0x00D6, 0x00C7, 0x00DC, 0x011E, 0x0131, 0x015F, 0x00F6, 0x00E7, 0x00FC }; /* D    TR    */
+//    { 0x0000, 0x0000, 0x0000, 0x0000, 0x005c, 0x00d7, 0x005d, 0x0000, 0x0000, 0x0000, 0x007c, 0x00cc, 0x007d};
+#endif
 
 
 inline int NationalOptionSubset(int chr) {
@@ -3155,8 +3198,8 @@ inline int NationalOptionSubset(int chr) {
         case 0x7d: return 11;
         case 0x7e: return 12;
     }
-    return -1;      
-}   
+    return -1;
+}
 
 inline unsigned int LeftBits(unsigned int bits) {
     // Scale bit positions 0xfc00 to 0xfff0 positions
@@ -3191,7 +3234,7 @@ unsigned int* GetFontChar(cTeletextChar c, unsigned int *buffer) {
     unsigned int *bitmap=NULL;
     int i;
     int NationalOption=NationalOptionSubset(chr);
-    
+
     switch (font) {
     case CHARSET_LATIN_G0:
         if (NationalOption>=0) {
@@ -3211,7 +3254,7 @@ unsigned int* GetFontChar(cTeletextChar c, unsigned int *buffer) {
             if (chr>=0x20 && chr<0x80) {
                 bitmap=TXT_Font[chr-0x20];
             }
-        }           
+        }
         break;
     case CHARSET_LATIN_G0_FR:
         if (NationalOption>=0) {
@@ -3221,7 +3264,7 @@ unsigned int* GetFontChar(cTeletextChar c, unsigned int *buffer) {
             if (chr>=0x20 && chr<0x80) {
                 bitmap=TXT_Font[chr-0x20];
             }
-        }           
+        }
         break;
     case CHARSET_LATIN_G0_IT:
         if (NationalOption>=0) {
@@ -3231,7 +3274,7 @@ unsigned int* GetFontChar(cTeletextChar c, unsigned int *buffer) {
             if (chr>=0x20 && chr<0x80) {
                 bitmap=TXT_Font[chr-0x20];
             }
-        }           
+        }
         break;
     case CHARSET_LATIN_G0_PT_ES:
         if (NationalOption>=0) {
@@ -3241,7 +3284,7 @@ unsigned int* GetFontChar(cTeletextChar c, unsigned int *buffer) {
             if (chr>=0x20 && chr<0x80) {
                 bitmap=TXT_Font[chr-0x20];
             }
-        }           
+        }
         break;
     case CHARSET_LATIN_G0_SV_FI:
         if (NationalOption>=0) {
@@ -3251,7 +3294,7 @@ unsigned int* GetFontChar(cTeletextChar c, unsigned int *buffer) {
             if (chr>=0x20 && chr<0x80) {
                 bitmap=TXT_Font[chr-0x20];
             }
-        }           
+        }
         break;
     case CHARSET_LATIN_G0_DE:
         if (chr>=0x20 && chr<0x80) {
@@ -3280,7 +3323,7 @@ unsigned int* GetFontChar(cTeletextChar c, unsigned int *buffer) {
             bitmap=TXT_Font[chr-0x20];
         }
         break;
-        
+
     case CHARSET_LATIN_G2:
     case CHARSET_CYRILLIC_G0_SR_HR:
     case CHARSET_CYRILLIC_G0_RU_BG:
@@ -3293,7 +3336,7 @@ unsigned int* GetFontChar(cTeletextChar c, unsigned int *buffer) {
     case CHARSET_HEBREW_G0:
         // totally unsupported
         break;
-        
+
     case CHARSET_GRAPHICS_G1:
         if (chr>=0x20 && chr<0x40) {
             bitmap=TXT_Font[chr-0x20+0x80];
@@ -3312,20 +3355,20 @@ unsigned int* GetFontChar(cTeletextChar c, unsigned int *buffer) {
             bitmap=buffer;
         }
         break;
-        
+
     case CHARSET_GRAPHICS_G3:
     case CHARSET_INVALID:
         // Totally unsupported
         break;
     }
-    
-    
-    
+
+
+
     if (!buffer) {
         printf("Warning: Undefined char: %x %x\n",font,chr);
         return NULL;
     }
-    
+
     switch (c.GetDblHeight()) {
     case dblh_Top:
         // Scale top 5 lines to full height
@@ -3377,6 +3420,137 @@ unsigned int* GetFontChar(cTeletextChar c, unsigned int *buffer) {
         bitmap=buffer;
     default:;
     }
-    
-    return bitmap;      
+
+    return bitmap;
+}
+
+
+unsigned int GetVTXChar(cTeletextChar c) {
+    // convert  character for character/charset to utf8
+    int convertedChar = 0;
+    enumCharsets font=c.GetCharset();
+    int chr=c.GetChar();
+    int NationalOption=NationalOptionSubset(chr);
+
+    switch (font) {
+    case CHARSET_LATIN_G0:
+        if (NationalOption>=0) {
+            if (NationalOptionSubsetG0Default[NationalOption]>0)
+                convertedChar = NationalOptionSubsetG0Default[NationalOption];
+        } else {
+            if (chr>=0x20 && chr<0x80) {
+                convertedChar = chr;
+            }
+        }
+        break;
+    case CHARSET_LATIN_G0_EN:
+        if (NationalOption>=0) {
+            if (NationalOptionSubsetEN[NationalOption]>0)
+                convertedChar = NationalOptionSubsetEN[NationalOption];
+        } else {
+            if (chr>=0x20 && chr<0x80) {
+                convertedChar = chr;
+            }
+        }
+        break;
+    case CHARSET_LATIN_G0_FR:
+        if (NationalOption>=0) {
+            if (NationalOptionSubsetFR[NationalOption]>0)
+                convertedChar = NationalOptionSubsetFR[NationalOption];
+        } else {
+            if (chr>=0x20 && chr<0x80) {
+                convertedChar = chr;
+            }
+        }
+        break;
+    case CHARSET_LATIN_G0_IT:
+        if (NationalOption>=0) {
+            if (NationalOptionSubsetIT[NationalOption]>0)
+                convertedChar = NationalOptionSubsetIT[NationalOption];
+        } else {
+            if (chr>=0x20 && chr<0x80) {
+                convertedChar = chr;
+            }
+        }
+        break;
+    case CHARSET_LATIN_G0_PT_ES:
+        if (NationalOption>=0) {
+            if (NationalOptionSubsetPT_ES[NationalOption]>0)
+                convertedChar = NationalOptionSubsetPT_ES[NationalOption];
+        } else {
+            if (chr>=0x20 && chr<0x80) {
+                convertedChar = chr;
+            }
+        }
+        break;
+    case CHARSET_LATIN_G0_SV_FI:
+        if (NationalOption>=0) {
+            if (NationalOptionSubsetSV_FI[NationalOption]>0)
+                convertedChar = NationalOptionSubsetSV_FI[NationalOption];
+        } else {
+            if (chr>=0x20 && chr<0x80) {
+                convertedChar = chr;
+            }
+        }
+        break;
+    case CHARSET_LATIN_G0_DE:
+        if (NationalOption>=0) {
+            if (NationalOptionSubsetDE[NationalOption]>0)
+                convertedChar = NationalOptionSubsetDE[NationalOption];
+        } else {
+            if (chr>=0x20 && chr<0x80) {
+                convertedChar = chr;
+            }
+        }
+        break;
+    case CHARSET_LATIN_G0_CZ_SK:
+        if (NationalOption>=0) {
+            if (NationalOptionSubsetCZ_SK[NationalOption]>0)
+                convertedChar = NationalOptionSubsetCZ_SK[NationalOption];
+        } else {
+            if (chr>=0x20 && chr<0x80) {
+                convertedChar = chr;
+	    }
+        }
+        break;
+
+    case CHARSET_LATIN_G0_EE:
+    case CHARSET_LATIN_G0_LV_LT:
+    case CHARSET_LATIN_G0_PL:
+    case CHARSET_LATIN_G0_RO:
+    case CHARSET_LATIN_G0_SR_HR_SL:
+    case CHARSET_LATIN_G0_TR:
+        // Partially supported latin charsets
+        if (chr>=0x20 && chr<0x80 && NationalOption<0) {
+            convertedChar = chr;
+        }
+        break;
+
+    case CHARSET_LATIN_G2:
+    case CHARSET_CYRILLIC_G0_SR_HR:
+    case CHARSET_CYRILLIC_G0_RU_BG:
+    case CHARSET_CYRILLIC_G0_UK:
+    case CHARSET_CYRILLIC_G2:
+    case CHARSET_GREEK_G0:
+    case CHARSET_GREEK_G2:
+    case CHARSET_ARABIC_G0:
+    case CHARSET_ARABIC_G2:
+    case CHARSET_HEBREW_G0:
+        // totally unsupported
+        break;
+
+    case CHARSET_GRAPHICS_G1:
+        convertedChar = chr + 0xee00;
+        break;
+    case CHARSET_GRAPHICS_G1_SEP:
+        convertedChar = chr + 0xee00 - 0x20;
+        break;
+
+    case CHARSET_GRAPHICS_G3:
+    case CHARSET_INVALID:
+        // Totally unsupported
+        break;
+    }
+    return convertedChar;
+
 }
diff --git a/txtfont.h b/txtfont.h
index 90b3cac..e6e4cac 100644
--- a/txtfont.h
+++ b/txtfont.h
@@ -6,11 +6,7 @@
 #include "txtrender.h"
 
 unsigned int* GetFontChar(cTeletextChar c, unsigned int *buffer);
-// Get a character bitmap for character/charset
-// Also handle double width/height partial characters
-// buffer must be an unsigned int[10] buffer, that *may* be used
-// to store the character - a different pointer may be returned too.
-// returns NULL if undefined character
 
+unsigned int GetVTXChar(cTeletextChar c);
 
 #endif
diff --git a/txtrecv.c b/txtrecv.c
index f59c804..281927e 100644
--- a/txtrecv.c
+++ b/txtrecv.c
@@ -86,7 +86,12 @@ void cTxtStatus::ChannelSwitch(const cDevice *Device, int ChannelNumber, bool Li
 
    // ignore if channel is invalid (highly unlikely, this will ever
    // be the case, but defensive coding rules!)
-   cChannel* newLiveChannel = Channels.GetByNumber(ChannelNumber);
+#if APIVERSNUM >= 20301
+   LOCK_CHANNELS_READ;
+   const cChannel* newLiveChannel = Channels->GetByNumber(ChannelNumber);
+#else
+   const cChannel* newLiveChannel = Channels.GetByNumber(ChannelNumber);
+#endif
    if (newLiveChannel == NULL) return;
 
    // ignore non-live-channel-switching
@@ -147,7 +152,11 @@ void cTxtReceiver::Activate(bool On)
      }
 }
 
+#if APIVERSNUM >= 20301
+void cTxtReceiver::Receive(const uchar *Data, int Length)
+#else
 void cTxtReceiver::Receive(uchar *Data, int Length)
+#endif
 {
    cFrame *frame=new cFrame(Data, Length);
    if (!buffer.Put(frame)) {
@@ -289,5 +298,3 @@ void cTxtReceiver::DecodeTXT(uchar* TXT_buf)
       break;
    }
 }
-
-
diff --git a/txtrecv.h b/txtrecv.h
index a1be1f4..823f9ef 100644
--- a/txtrecv.h
+++ b/txtrecv.h
@@ -56,7 +56,11 @@ private:
    Storage *storage;
 protected:
    virtual void Activate(bool On);
+#if APIVERSNUM >= 20301
+   virtual void Receive(const uchar *Data, int Length);
+#else
    virtual void Receive(uchar *Data, int Length);
+#endif
    virtual void Action();
 public:
    cTxtReceiver(const cChannel* chan, bool storeTopText, Storage* storage);
diff --git a/txtrender.h b/txtrender.h
index 850927e..208b41b 100644
--- a/txtrender.h
+++ b/txtrender.h
@@ -142,7 +142,7 @@ public:
     // For each parameter encoded into the 32-bit int, there is
     // a Get...() to read, a Set...() to write, and a To...() to
     // return a modified copy
-    
+    inline unsigned int GetC() { return c;};
     inline unsigned char GetChar() 
         { return c&CHAR; }
     inline void SetChar(unsigned char chr)
